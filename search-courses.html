<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Search golf courses | Golf Done Better</title>
<link href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" rel="stylesheet"/>
<link href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" rel="stylesheet"/>
<style>

/* Hide prototype and local-server notes */
.prototype-note, .dev-note, #prototypeNote, #devNote, #notes, .notes { display:none !important; }


    :root{--bg:#0b1713;--fg:#f5f5f5;--card:rgba(255,255,255,.05);--bd:rgba(255,255,255,.12)}
    *{box-sizing:border-box}
    body{margin:0;font-family:Arial,Helvetica,sans-serif;background: radial-gradient(1200px 600px at 50% 0%, rgba(255,255,255,.06), rgba(11,23,19,.96) 60%), linear-gradient(#0b1713, #0b1713);color:var(--fg)}
    a{color:inherit;text-decoration:none}

    header{position:sticky;top:0;z-index:8000;background:rgba(11,23,19,.78);backdrop-filter:blur(10px);border-bottom:1px solid rgba(255,255,255,.10)}
    /* Wider canvas so the map does not feel squeezed when filters are in a sidebar */
    .header-inner{width:100%;max-width:none;margin:0 auto;padding:14px 18px;display:flex;align-items:center;justify-content:space-between;gap:18px}

    /* Top right menu */
    .page-menu{position:relative;z-index:8100}
    .menu-btn{
  width:54px;
  height:54px;
  border-radius:16px;
  background:rgba(11,23,19,.55);
  border:1px solid rgba(255,255,255,.22);
  color:#ffffff;
  cursor:pointer;
  display:flex;
  align-items:center;
  justify-content:center;
  backdrop-filter:blur(10px);
}
.menu-btn svg{width:28px;height:28px;display:block}
    .menu-btn:hover{background:rgba(255,255,255,.12)}
    .menu-panel{position:absolute;right:0;top:54px;min-width:240px;background:rgba(11,23,19,.92);border:1px solid rgba(255,255,255,.14);border-radius:14px;overflow:hidden;display:none;box-shadow:0 18px 60px rgba(0,0,0,.45);backdrop-filter:blur(10px);text-align:left;z-index:8100}
    .menu-panel a{display:block;padding:12px 14px;font-weight:900;opacity:.95;color:#ffffff}
    .menu-panel a:hover{background:rgba(255,255,255,.08);opacity:1}
    .menu-sep{height:1px;background:rgba(255,255,255,.10);margin:6px 0}

    .wrap{width:100%;max-width:none;margin:0 auto}
    .intro{padding:18px}
    .intro h1{margin:0 0 6px;font-size:26px}
    .intro p{margin:0;opacity:.88}
    .note{margin-top:8px;font-size:13px;opacity:.70}

    .modes{display:flex;gap:12px;flex-wrap:wrap;align-items:center;padding:0 18px 14px}
    .btn{padding:12px 16px;border-radius:12px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.22);cursor:pointer;font-weight:900;color:#fff}
    .btn:hover{background:rgba(255,255,255,.10)}
    .btn.active{border-color:rgba(110,231,183,.65);background:rgba(110,231,183,.16)}
    .prompt{opacity:.85}

    .filters-wrap{display:block;padding:0;position:sticky;z-index:2000;top:74px}
    .filters-bar{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;background:rgba(11,23,19,.78);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.14);border-radius:14px;padding:8px 10px}
/* Tighten filters header spacing */
#filtersWrap .filters-left{gap:6px}
#filtersWrap .filters-actions{gap:8px;margin-bottom:4px}
#filtersWrap #toggleFilters{padding-top:6px;padding-bottom:6px}

    
.filters-actions{display:flex;gap:10px;align-items:center;flex-wrap:nowrap}
@media (max-width:420px){.filters-actions{flex-wrap:wrap}}
.filters-left{display:flex;gap:10px;flex-wrap:nowrap;align-items:center}
@media (max-width:520px){.filters-left{flex-wrap:wrap}}

/* Sidebar filter header: center the counter under the action buttons */
.sidecol .filters-left{
  flex-direction:column;
  align-items:center;
  gap: 4px;
  width:100%;
}
.sidecol .filters-actions{
  justify-content:center;
  width:100%;
}
.sidecol .chip-static{
  justify-content:center;
  margin:0 auto;
}
.sidecol .smallhint{ text-align:center; }

    .filters-right{display:flex;gap:10px;align-items:center}
    .chip{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.18);border-radius:999px;padding:9px 12px;color:#fff;cursor:pointer;font-weight:900;font-size:13px;display:flex;gap:8px;align-items:center}
    .chip:hover{background:rgba(255,255,255,.10)}
        .chip-static{cursor:default;user-select:none}
    .chip-static:hover{background:rgba(255,255,255,.06)}
.chip-count{opacity:.8;font-weight:900;font-size:12px}
    .smallhint{font-size:13px;opacity:.78}

    .filters-panel{margin-top:10px;background:rgba(11,23,19,.92);border:1px solid rgba(255,255,255,.12);border-radius:14px;overflow:hidden;display:block}
    .filters-panel-inner{padding:10px;display:flex;flex-direction:column;gap:10px}
    /* Accordion filter groups */
    details.acc{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.12);border-radius:12px;overflow:hidden}
    details.acc[open]{border-color:rgba(110,231,183,.38)}
    details.acc > summary{cursor:pointer;user-select:none;list-style:none;display:flex;align-items:center;justify-content:space-between;gap:10px;padding:12px 12px;font-weight:900}
    details.acc > summary::-webkit-details-marker{display:none}
    details.acc > summary .sum-left{display:flex;align-items:center;gap:10px}
    details.acc > summary .sum-pill{font-size:12px;font-weight:900;opacity:.9;border:1px solid rgba(255,255,255,.18);background:rgba(11,23,19,.40);border-radius:999px;padding:4px 8px}
    details.acc > summary:hover{background:rgba(255,255,255,.05)}
    .acc-body{padding:12px;border-top:1px solid rgba(255,255,255,.10)}
    .fopts{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
    @media (max-width:420px){.fopts{grid-template-columns:1fr}}
    .fopt{display:grid;grid-template-columns:18px 1fr;column-gap:8px;align-items:start;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:10px}
    .fopt input{transform:scale(1.05);margin-top:2px}
    .filters-footer-actions{padding:10px 14px;border-top:1px solid rgba(255,255,255,.10);display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center}
    .filters-actions-row{display:flex;gap:10px;align-items:center}
    @media (max-width:980px){.filters-actions-row{width:100%}.filters-actions-row .btn{flex:1 1 auto}}


    #mapWrap{position:relative;display:none}
    .map-clear{position:absolute;top:12px;right:12px;z-index:950;padding:10px 12px;border-radius:12px;background:rgba(11,23,19,.68);border:1px solid rgba(255,255,255,.22);color:#fff;font-weight:900;cursor:pointer;backdrop-filter:blur(6px)}
    .map-clear:hover{background:rgba(255,255,255,.10)}
    .map-reset{position:absolute;top:12px;right:118px;z-index:950;padding:10px 12px;border-radius:12px;background:rgba(11,23,19,.68);border:1px solid rgba(255,255,255,.22);color:#fff;font-weight:900;cursor:pointer;backdrop-filter:blur(6px)}
    .map-reset:hover{background:rgba(255,255,255,.10)}

    .live-pill{position:absolute;top:12px;left:56px;z-index:950;padding:8px 12px;border-radius:999px;background:rgba(11,23,19,.62);border:1px solid rgba(255,255,255,.18);backdrop-filter:blur(6px);font-size:13px;font-weight:900;opacity:.95;pointer-events:none;white-space:nowrap}
    #map{height:440px;width:100%;border-top:1px solid rgba(255,255,255,.08);border-bottom:1px solid rgba(255,255,255,.08)}
    .map-instruction{position:absolute;top:12px;left:50%;transform:translateX(-50%);background:rgba(11,23,19,.62);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.18);border-radius:999px;padding:8px 14px;font-size:14px;font-weight:900;z-index:900;pointer-events:none;white-space:nowrap}
    /* Text Search: hide drawing tools. Text mode is driven by the search bar, not map selection */
    body.mode-text .leaflet-draw{display:none !important;}


    .sort-row{display:none;padding:12px 18px 0;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .hint{font-size:14px;opacity:.78}
    select{padding:8px 10px;border-radius:10px;background:#ffffff;border:1px solid rgba(255,255,255,.22);color:#0b1713;font-weight:800}
    select option{color:#0b1713;}
    select option{color:#0b1713}


    .type-toggles{display:flex;gap:8px;flex-wrap:wrap;align-items:center;max-width:100%}
    .tchip{white-space:nowrap}
    @media (max-width:620px){.type-toggles{flex-wrap:nowrap;overflow-x:auto;padding-bottom:2px;-webkit-overflow-scrolling:touch}.tlabel{display:none}.tchip{padding:7px 9px;font-size:12px}}
    .tlabel{font-size:13px;opacity:.78;font-weight:900}
    .tchip{display:flex;gap:8px;align-items:center;padding:8px 10px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.18);cursor:pointer;font-weight:900;font-size:13px;user-select:none}
    .tchip:hover{background:rgba(255,255,255,.10)}
    .tchip input{accent-color:#6ee7b7}
    .tchip.disabled{opacity:.55;cursor:default}
    .tchip.disabled:hover{background:rgba(255,255,255,.06)}

    .text-search{display:none;padding:0 18px 18px}
    .text-search input{width:100%;padding:14px;border-radius:12px;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.04);color:var(--fg);font-size:16px;outline:none}

    .textbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .textbar input{flex:1 1 360px}
    
    .acwrap{position:relative;flex:1 1 360px;min-width:260px}
    .acwrap input{width:100%}
    .ac-panel{
      position:absolute;
      left:0;right:0;
      top:calc(100% + 8px);
      background:rgba(11,23,19,.96);
      border:1px solid rgba(255,255,255,.14);
      border-radius:14px;
      box-shadow:0 18px 60px rgba(0,0,0,.45);
      backdrop-filter:blur(10px);
      overflow:hidden;
      display:none;
      z-index:9900;
      max-height:280px;
      overflow:auto;
    }
    .ac-item{
      padding:10px 12px;
      cursor:pointer;
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    .ac-item:last-child{border-bottom:none}
    .ac-item:hover{background:rgba(255,255,255,.08)}
    .ac-top{font-weight:900;font-size:13px;line-height:1.2}
    .ac-sub{font-size:12px;opacity:.75;margin-top:2px;line-height:1.2}
.textbar select{flex:0 0 140px;min-width:140px;height:46px;border-radius:12px;border:1px solid rgba(255,255,255,.16);background:#ffffff;color:#0b1713;font-weight:900;padding:10px 12px}
    .textbar .btn{height:46px;padding:12px 16px;border-radius:12px}
    @media (max-width:560px){.textbar select{flex:1 1 160px}.textbar .btn{flex:1 1 100%}}



    /* Two column layout: frozen filters on the left, content on the right */
    .layout{display:block;padding:0 18px 18px}
    /* Use flex for the two column view so the map never drops underneath on wider screens */
    /* Sidebar sizing tweaks */
    .layout.with-filters{--filtersW:260px;display:flex;gap:16px;align-items:flex-start}
    /* Sidebar must sit next to the map (not above it) */
    .layout.with-filters > .filters-wrap{
      display:block;
      flex:0 0 var(--filtersW);
      width:var(--filtersW);
      padding:0;                 /* layout already provides page padding */
      position:sticky;
      top:var(--stickyTop, 74px);
      max-height:calc(100vh - var(--stickyTop, 74px) - 18px);
      overflow:auto;
      align-self:flex-start;
    }
    .layout.with-filters > .maincol{
      flex:1 1 auto;
      min-width:0;               /* prevents map dropping under due to overflow */
    }


    /* Compact sidebar typography and spacing */
    .filters-wrap{font-size:13px;line-height:1.25}
    .filters-bar{padding:8px 10px}
    .chip{padding:7px 10px;font-size:12px}
    .chip-count{font-size:11px}
    .smallhint{font-size:12px}
    .filters-panel-inner{padding:8px;gap:8px}
    details.acc > summary{padding:10px 10px;font-size:13px}
    details.acc > summary .sum-pill{font-size:11px;padding:3px 7px}
    .acc-body{padding:10px}
    .fopts{gap:8px}
    .fopt{padding:8px;border-radius:10px}
    .fopt input{transform:scale(1.0)}
    .filters-actions{padding:8px 10px}

    @media (max-width:1100px){
      .layout.with-filters{--filtersW:260px;}
    }
    @media (max-width:920px){
      .layout.with-filters{--filtersW:240px;}
      .fopts{grid-template-columns:1fr}
    }

    /* Remove extra side padding inside the right column */
    .maincol .sort-row,.maincol .text-search,.maincol .results{padding-left:0;padding-right:0}
    /* On smaller screens, stack */
    @media (max-width:560px){
      .layout.with-filters{display:block}
      .filters-wrap{position:relative;top:auto;width:auto;max-height:none;overflow:visible;margin-bottom:14px}
      .filters-bar{flex-direction:row;align-items:center}
      .filters-left{flex-direction:row;align-items:center}
      .filters-right{justify-content:flex-end}
    }

    
    /* Hard override to ensure sidebar sits beside the map on desktop */
    #pageLayout.with-filters{
      display:flex;
      flex-direction:row;
      flex-wrap:nowrap;
      align-items:flex-start;
    }
    #pageLayout.with-filters > .filters-wrap{flex:0 0 var(--filtersW); width:var(--filtersW);}
    #pageLayout.with-filters > .maincol{flex:1 1 auto; min-width:0;}
    /* Only stack on small screens */

    /* Neat action buttons (cards and popup) */
    .course-actions{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:12px;
    }
    .course-actions .link{
      flex:1 1 calc(33.333% - 10px);
      min-width:118px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:10px 10px;
      border-radius:12px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.18);
      font-size:13px;
      font-weight:900;
      line-height:1.15;
      opacity:.95;
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
    }
    .course-actions .link:hover{background:rgba(255,255,255,.10);text-decoration:none}
    /* On very narrow widths, stack buttons */
    @media (max-width:560px){
      .course-actions .link{flex:1 1 100%}
    }
    @media (max-width:560px){
      #pageLayout.with-filters{display:block;}
      #pageLayout.with-filters > .filters-wrap{width:auto;max-height:none;overflow:visible;position:relative;top:auto;}
    }

/* Popup card layout: tidy, use full width */
    .panel-card{display:block}
    .panel-body{
      padding:14px;
      display:grid;
      grid-template-columns:78px 1fr;
      column-gap:12px;
      row-gap:12px;
      min-width:0;
    }
    .panel-badges{
      grid-column:1 / -1;
      display:flex;
      align-items:center;
      justify-content:flex-start;
      gap:10px;
    }
    .panel-body .img-badge{
      position:static;
      left:auto;
      top:auto;
      display:inline-flex;
      align-items:center;
    }
    .panel-thumb{
      width:78px;
      height:78px;
      border-radius:12px;
      object-fit:cover;
      flex:0 0 auto;
      background:linear-gradient(135deg, rgba(255,255,255,.08), rgba(255,255,255,.02));
      filter:saturate(1.05) contrast(1.05);
    }
    .panel-titlewrap{
      min-width:0;
      padding-right:78px;
      align-self:center;
    }
    .panel-titlewrap .course-name{
      font-size:18px;
      white-space:normal;
      overflow:visible;
      text-overflow:clip;
    }
    .panel-titlewrap .course-location{margin-top:4px}
    .panel-meta{
      grid-column:1 / -1;
      margin-top:0;
    }
    .panel-body .course-actions{
      grid-column:1 / -1;
      margin-top:0;
    }

/* Map quick view panel */
    .map-sidepanel{
      position:absolute;top:12px;right:12px;z-index:970;
      width:360px;max-width:calc(100% - 24px);
      max-height:calc(100% - 24px);
      overflow:hidden;
      background:rgba(11,23,19,.92);
      border:1px solid rgba(255,255,255,.14);
      border-radius:16px;
      box-shadow:0 18px 60px rgba(0,0,0,.45);
      backdrop-filter:blur(10px);
      display:none;
      flex-direction:column;
    }
    .map-sidepanel-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px;
      position:sticky;
      top:0;
      z-index:2;
      background:rgba(11,23,19,.96);
      border-bottom:1px solid rgba(255,255,255,.12);
    }
    .map-sidepanel-title{font-weight:900;opacity:.9;font-size:13px}
    .map-sidepanel-close{
      width:34px;height:34px;border-radius:10px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.06);
      color:#fff;cursor:pointer;font-weight:900;
      display:flex;align-items:center;justify-content:center;
    }
    .map-sidepanel-close:hover{background:rgba(255,255,255,.10)}
    .map-sidepanel-body{
      padding:12px;
      overflow:auto;
      flex:1 1 auto;
      min-height:0;
    }
    .map-sidepanel .course-card{margin:0;transform:none}
    .map-sidepanel .course-card:hover{transform:none}
        .map-sidepanel .img-badge{display:none !important;}
.map-sidepanel .course-card.panel-card{
      display:block !important;
      grid-template-columns:none !important;
    }
    .map-sidepanel .save{
      position:absolute;
      top:10px;
      right:10px;
      z-index:8;
      background:rgba(11,23,19,.72);
      border:1px solid rgba(255,255,255,.22);
    }

        /* Popup uses panel-card markup, keep spacing tight */
    .map-sidepanel .course-card{margin:0;transform:none}
    .map-sidepanel .course-card:hover{transform:none}
        .map-sidepanel .img-badge{display:none !important;}
.map-sidepanel .course-card.panel-card{
      display:block !important;
      grid-template-columns:none !important;
    }
    .map-sidepanel .save{
      position:absolute;
      top:10px;
      right:10px;
      z-index:8;
      background:rgba(11,23,19,.72);
      border:1px solid rgba(255,255,255,.22);
    }

    @media (max-width:920px){
      .map-sidepanel{top:auto;bottom:12px;right:12px;left:12px;width:auto}
    }
.results{display:none;padding:14px 18px 60px}
    .results h2{margin:0 0 14px;font-size:20px}
    .course-card{position:relative;background:var(--card);border:1px solid var(--bd);border-radius:16px;margin-bottom:14px;display:grid;grid-template-columns:220px 1fr;overflow:hidden;transition:background .15s,border-color .15s,transform .12s}
    .course-card:hover{background:rgba(255,255,255,.07);border-color:rgba(110,231,183,.35);transform:translateY(-1px)}
    .course-img{width:100%;height:100%;min-height:190px;object-fit:cover;display:block;background:linear-gradient(135deg, rgba(255,255,255,.08), rgba(255,255,255,.02));filter:saturate(1.05) contrast(1.05)}
    .course-body{padding:16px;display:grid;gap:12px;min-width:0}
    .save{position:absolute;top:12px;right:12px;width:34px;height:34px;border-radius:10px;border:1px solid rgba(255,255,255,.18);background:rgba(11,23,19,.60);backdrop-filter:blur(6px);display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:18px;user-select:none;z-index:5}
    .save:hover{background:rgba(255,255,255,.10)}
    .course-name{font-weight:900;font-size:18px;line-height:1.15}
    .pill{display:inline-block;margin-left:8px;padding:2px 8px;border:1px solid rgba(255,255,255,.18);border-radius:999px;font-size:11px;opacity:.9;vertical-align:middle}
    .course-location{font-size:13px;opacity:.75;margin-top:2px}
    .meta-grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.10);border-radius:12px;padding:10px}
    .meta-label{font-size:11px;letter-spacing:.6px;text-transform:uppercase;opacity:.65}
    .meta-value{font-size:13px;font-weight:900;margin-top:3px;opacity:.95;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .meta-value.wrap{white-space:normal;overflow:visible;text-overflow:clip;line-height:1.25}
    .img-badge{position:absolute;left:12px;top:12px;z-index:6;background:rgba(11,23,19,.60);border:1px solid rgba(255,255,255,.18);backdrop-filter:blur(6px);border-radius:999px;padding:6px 10px;font-weight:900;font-size:12px;opacity:.92}

    @media (max-width:860px){.course-card{grid-template-columns:160px 1fr}.meta-grid{grid-template-columns:repeat(2,minmax(0,1fr))}}
    @media (max-width:540px){.course-card{grid-template-columns:1fr}.course-img{min-height:180px}.meta-grid{grid-template-columns:1fr}}
    @media (max-width:768px){#map{height:340px}}
  
    
    /* Right sidebar filters layout */
    .layout.with-filters{--filtersW:260px}
    .sidecol{
      width:var(--filtersW);
      flex:0 0 var(--filtersW);
      min-width:220px;
      max-width:260px;
      position:sticky;
      top:74px;
      align-self:flex-start;
      max-height:calc(100vh - 90px);
      overflow:auto;
      padding-bottom:18px;
    }
    .sidecol .filters-bar{
      position:sticky;
      top:0;
      z-index:5;
      padding:10px;
      border-radius:14px;
    }
    .sidecol .filters-panel{margin-top:10px}
    .sidecol .filters-panel-inner{padding:10px}
    .sidecol .smallhint{font-size:12px;line-height:1.25;opacity:.9}
    .sidecol summary{font-size:13px}
    .sidecol .fopt{font-size:13px}
    .sidecol .btn{padding:9px 10px;border-radius:10px;font-size:13px}
    .sidecol .chip{padding:8px 10px;border-radius:12px;font-size:13px}

    /* Keep layout usable on smaller screens */
    @media (max-width: 980px){
      .layout.with-filters{flex-direction:column}
      .sidecol{width:100%;max-width:none;position:static;max-height:none;overflow:visible}
    }

.brand svg{width:180px;height:auto;display:block}
.brand{display:flex;align-items:center;gap:12px;padding-left:6px}


/* SEO and accessibility helpers */
.skip-link{position:absolute;left:-999px;top:12px;background:#6ee7b7;color:#0b1713;padding:10px 14px;border-radius:12px;font-weight:900;z-index:9999;text-decoration:none}
.skip-link:focus{left:12px}
.site-footer{padding:18px;border-top:1px solid rgba(255,255,255,.12);background:rgba(11,23,19,.92);color:rgba(255,255,255,.86);font-size:13px;line-height:1.4}

/* Compare */
#gdbToast{
  position:fixed;left:50%;bottom:20px;z-index:9999;
  transform:translate(-50%, 8px);
  background:rgba(0,0,0,.78);border:1px solid rgba(255,255,255,.18);
  color:#fff;padding:10px 12px;border-radius:12px;font-weight:900;
  opacity:0;pointer-events:none;transition:.22s ease;
  max-width:320px;text-align:center;
}
#gdbToast.show{opacity:1;transform:translate(-50%, 0)}
#compareWidget{
  position:fixed;left:50%;bottom:20px;z-index:9998;
  transform:translateX(-50%);
  background:rgba(11,23,19,.92);backdrop-filter:blur(10px);
  border:1px solid rgba(255,255,255,.18);border-radius:14px;
  padding:10px 10px;gap:10px;align-items:center;
  cursor:grab;user-select:none;
  box-shadow:0 18px 60px rgba(0,0,0,.35);
}
#compareWidget .compare-widget-inner{display:flex;flex-direction:column;line-height:1.05}
#compareWidget .compare-widget-title{font-weight:900}
#compareWidget .compare-widget-sub{opacity:.82;font-size:12px;font-weight:900}
#compareWidget .compare-open{
  border-radius:12px;border:1px solid rgba(255,255,255,.22);
  background:rgba(255,255,255,.08);color:#fff;font-weight:900;
  padding:10px 12px;cursor:pointer;
}
#compareWidget .compare-open:hover{background:rgba(255,255,255,.12)}

.compare-modal{position:fixed;inset:0;z-index:9997;display:none}
.compare-modal.show{display:block}
.compare-backdrop{position:absolute;inset:0;background:rgba(0,0,0,.55)}
.compare-panel{
  position:relative;max-width:1100px;margin:50px auto;
  background:rgba(11,23,19,.98);border:1px solid rgba(255,255,255,.18);
  border-radius:18px;box-shadow:0 18px 80px rgba(0,0,0,.55);
  padding:14px;max-height:calc(100vh - 100px);overflow:auto;
}
@media (max-width:900px){.compare-panel{margin:16px;max-height:calc(100vh - 32px)}}
.compare-head{display:flex;align-items:flex-start;justify-content:space-between;gap:12px;margin-bottom:12px}
.compare-title{font-size:18px;font-weight:900}
.compare-sub{font-size:12px;opacity:.8;font-weight:900;margin-top:4px}
.compare-x{
  border-radius:12px;border:1px solid rgba(255,255,255,.22);
  background:rgba(255,255,255,.06);color:#fff;font-weight:900;
  padding:10px 12px;cursor:pointer;
}
.compare-x:hover{background:rgba(255,255,255,.10)}
.compare-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
@media (max-width:980px){.compare-grid{grid-template-columns:repeat(2,1fr)}}
@media (max-width:640px){.compare-grid{grid-template-columns:1fr}}
.compare-card{
  background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.14);
  border-radius:16px;overflow:hidden;position:relative;
}
.compare-card .compare-remove{
  position:absolute;top:10px;right:10px;z-index:2;
  border-radius:12px;border:1px solid rgba(255,255,255,.22);
  background:rgba(0,0,0,.35);color:#fff;font-weight:900;
  padding:8px 10px;cursor:pointer;
}
.compare-card .compare-remove:hover{background:rgba(0,0,0,.45)}

/* Compare toggle on cards */
.compare-toggle{
  position:absolute;top:10px;right:10px;z-index:5;
  display:flex;flex-direction:column;align-items:center;gap:4px;
  background:rgba(0,0,0,.28);border:1px solid rgba(255,255,255,.18);
  border-radius:12px;padding:8px 9px;cursor:pointer;
  color:#fff;
}
.compare-toggle:hover{background:rgba(0,0,0,.36)}
.compare-toggle .icon{font-size:15px;line-height:1;color:#fff}
.compare-toggle .label{font-size:10px;font-weight:900;opacity:.92;color:#fff}
.compare-toggle.compact{padding:6px 7px;border-radius:10px}
.compare-toggle.compact .icon{font-size:13px}
.compare-toggle.compact .label{font-size:9px}
.compare-toggle.on{background:rgba(212,175,55,.20);border-color:rgba(212,175,55,.70)}
.compare-toggle.on .icon{color:rgba(212,175,55,.95)}


/* Filters header compact spacing */
#toggleFilters{padding:6px 10px;margin-top:6px}
#toggleFilters .chip-count{margin-left:6px}
.filters-left{gap:8px}
#selectAreaHint{margin-top:4px}



/* Mini confirm modal (used for Clear compare) */
.mini-modal{position:fixed;inset:0;z-index:9999;display:none}
.mini-modal.show{display:block}
.mini-backdrop{position:absolute;inset:0;background:rgba(0,0,0,.55)}
.mini-panel{
  position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
  width:min(520px, calc(100vw - 32px));
  background:#000;border:1px solid rgba(255,255,255,.16);
  border-radius:16px;padding:18px;box-shadow:0 12px 40px rgba(0,0,0,.55);
  color:#fff;
}
.mini-text{font-weight:900;font-size:15px;line-height:1.35}
.mini-actions{display:flex;gap:10px;justify-content:flex-end;margin-top:14px;flex-wrap:wrap}


/* --- GDB polish: tighter filter header spacing --- */
.filters-left{gap:6px;row-gap:6px}
.filters-actions{gap:8px}
#toggleFilters{margin:0}


/* === FILTER SIDEBAR HEADER: FORCE FIXED + COMPRESS === */

/* Kill all sticky/fixed behaviour in filter column */
.sidecol,
.sidecol *{
  position: static !important;
  top: auto !important;
}

/* Actual header block inside filters */
.sidecol .filters-header{
  padding-top: 6px !important;
  padding-bottom: 6px !important;
  margin-bottom: 6px !important;
}

/* Button row stays same size, less air */
.sidecol .filters-actions{
  margin-top: 0 !important;
  margin-bottom: 4px !important;
}

/* Counter spacing tightened */
.sidecol .chip-static{
  margin-top: 2px !important;
  margin-bottom: 4px !important;
}

/* Helper text */
.sidecol .smallhint{
  margin-top: 0 !important;
  margin-bottom: 4px !important;
}

/* Collapse flex spacing */
.sidecol .filters-left{
  gap: 4px !important;
}


/* === FILTER HEADER: HEIGHT COMPRESSION ONLY (NO POSITION CHANGES) === */

/* Reduce header vertical size decisively */
.sidecol .filters-header{
  padding-top: 4px !important;
  padding-bottom: 4px !important;
}

/* Reduce space between elements */
.sidecol .filters-left{
  gap: 2px !important;
}

/* Button row spacing */
.sidecol .filters-actions{
  margin-bottom: 2px !important;
}

/* Counter spacing */
.sidecol .chip-static{
  margin-top: 0 !important;
  margin-bottom: 2px !important;
}

/* Helper text */
.sidecol .smallhint{
  margin-top: 0 !important;
  margin-bottom: 0 !important;
}


/* =========================================
   1. FLOAT ENTIRE FILTERS BAR (ONE BLOCK)
   ========================================= */

.sidecol{
  position: sticky !important;
  top: 16px !important;
}

/* Ensure nothing inside becomes independently sticky */
.sidecol *{
  position: static;
}

/* =========================================
   2. FILTER TAB ARROWS (CENTER, VISUAL ONLY)
   ========================================= */

.filter-group > .filter-group-header{
  position: relative;
}

.filter-group > .filter-group-header::after{
  content: "▾";
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  font-size: 14px;
  opacity: 0.7;
  pointer-events: none;
}

.filter-group.collapsed > .filter-group-header::after{
  content: "▸";
}

/* =========================================
   3. REMOVE MAP 'SHOW COURSES' TOGGLE
   ========================================= */

/* Leaflet layers control (old show courses toggle) */
.leaflet-control-layers,
.leaflet-control-layers-expanded{
  display: none !important;
}


/* =========================================
   FILTERS BAR OFFSET BELOW PAGE HEADER
   ========================================= */

/* Adjust sticky offset to sit below main page header */
.sidecol{
  top: 96px !important; /* matches full page header height */
}

/* =========================================
   SEARCH MODE BUTTONS – CENTER + TITLE CASE
   ========================================= */

/* Center search buttons with page heading */
.search-modes{
  justify-content: center !important;
  margin-left: auto;
  margin-right: auto;
}

/* Button text case */
.search-modes button{
  text-transform: none;
}


/* ================================
   SEARCH MODE BUTTONS – FINAL FIX
   ================================ */

.search-modes{
  display: flex !important;
  justify-content: center !important;
  gap: 12px;
  width: 100%;
}


/* ================================
   CENTER SEARCH BUTTONS WITH PAGE HEADER
   ================================ */

/* Match heading container width */
.search-modes{
  max-width: 1100px;
  margin-left: auto !important;
  margin-right: auto !important;
  justify-content: center !important;
}


/* ================================
   FORCE SEARCH BUTTONS DEAD-CENTER
   ================================ */

.search-modes{
  width: 100% !important;
  display: flex !important;
  justify-content: center !important;
  align-items: center;
  text-align: center;
}


/* ================================
   ABSOLUTE CENTERING – NO DEPENDENCIES
   ================================ */

/* Center the entire block itself */
.search-modes{
  position: relative !important;
  left: 50% !important;
  transform: translateX(-50%) !important;
  display: inline-flex !important;
  justify-content: center !important;
}

/* Ensure parent allows centering */
.search-modes-wrapper,
.search-modes-container,
.search-modes-parent{
  text-align: center !important;
}


/* ================================
   CENTER SEARCH MODE BUTTONS (REAL SELECTOR)
   Buttons live in: section.modes
   ================================ */
.modes{
  justify-content: center !important;
  text-align: center;
}
.modes .prompt{
  width: 100%;
  text-align: center;
}


/* Center arrow between left label and right pill */
/* When closed */
/* =========================================
   FILTER DROPDOWN ARROWS (VISUAL ONLY, NO LAYOUT SHIFT)
   Keeps: name left, pill right. Adds centered arrow.
   ========================================= */

details.acc > summary{
  position: relative; /* anchor for the arrow */
}

/* Center arrow without changing existing flex layout */
/* When closed */
/* Safety: ensure pill stays right if any layout gets weird */
details.acc > summary .sum-pill{
  margin-left: auto;
}


/* =========================================
   FILTER DROPDOWN ARROWS – FINAL (NO LAYOUT SHIFT)
   Requirement:
   - Name stays left
   - Any pill stays right
   - Arrow centered between
   - Closed: down arrow
   - Open: up arrow
   ========================================= */

details.acc > summary{
  position: relative !important; /* anchor for arrow */
}

/* Center arrow without affecting layout */
details.acc > summary::after{
  content: "▾" !important; /* closed = down */
  position: absolute !important;
  left: 50% !important;
  top: 50% !important;
  transform: translate(-50%, -50%) !important;
  font-size: 14px !important;
  line-height: 1 !important;
  opacity: 0.65 !important;
  pointer-events: none !important;
}

/* Open = up */
details.acc[open] > summary::after{
  content: "▴" !important;
}

/* Ensure pill stays pinned right */
details.acc > summary .sum-pill{
  margin-left: auto !important;
}


/* Center top search mode buttons with heading */
.modes{
  justify-content: center !important;
}


/* ================================
   Compare modal grid/cards
   ================================ */
#compareModal .compare-modal-panel{max-width: 1240px; width: min(1240px, 96vw);}
#compareGrid{
  display:grid;
  gap:14px;
  grid-template-columns: repeat(3, minmax(0, 1fr));
}
#compareModal[data-count="2"] #compareGrid{grid-template-columns: repeat(2, minmax(0, 1fr));}
#compareModal[data-count="1"] #compareGrid{grid-template-columns: 1fr;}
@media (max-width: 980px){
  #compareGrid{grid-template-columns: repeat(2, minmax(0, 1fr));}
}
@media (max-width: 640px){
  #compareGrid{grid-template-columns: 1fr;}
}
.compare-card{
  position:relative;
  border:1px solid rgba(255,255,255,.08);
  border-radius:16px;
  overflow:hidden;
  background:rgba(20,20,20,.7);
}
.compare-remove{
  position:absolute; top:10px; right:10px;
  width:34px; height:34px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.18);
  background:rgba(0,0,0,.45);
  color:#fff; font-weight:900;
  cursor:pointer;
  z-index:2;
}
.compare-remove:hover{background:rgba(0,0,0,.65);}
.compare-imgwrap{height:150px; overflow:hidden; background:rgba(0,0,0,.25);}
.compare-imgwrap img{width:100%; height:100%; object-fit:cover; display:block;}
.compare-body{padding:12px 12px 14px;}
.compare-body .dim{opacity:.85;}
.compare-meta{
  margin-top:10px;
  display:grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap:8px 10px;
  font-size:12.5px;
}
.meta-row{
  display:flex; justify-content:space-between; gap:10px;
  border-bottom:1px solid rgba(255,255,255,.06);
  padding-bottom:6px;
}
.meta-row.meta-wide{grid-column:1 / -1;}
.meta-row span{opacity:.75;}
.compare-desc{margin-top:10px; font-size:13px; line-height:1.35; opacity:.92;}
.compare-links{margin-top:10px; display:flex; flex-wrap:wrap; gap:10px;}

</style>
<meta content="Search golf courses by map area or by location. Filter by holes, access, price range, difficulty, facilities, and vibe. No live availability or price guarantees." name="description"/><link href="https://golfdonebetter.com/search-courses" rel="canonical"/><meta content="index,follow,max-image-preview:large" name="robots"/><meta content="#0b1713" name="theme-color"/><meta content="Golf Done Better" property="og:site_name"/><meta content="website" property="og:type"/><meta content="https://golfdonebetter.com/search-courses" property="og:url"/><meta content="Search golf courses | Golf Done Better" property="og:title"/><meta content="Search golf courses by map area or by location. Filter by holes, access, price range, difficulty, facilities, and vibe. No live availability or price guarantees." property="og:description"/><meta content="summary" name="twitter:card"/><meta content="Search golf courses | Golf Done Better" name="twitter:title"/><meta content="Search golf courses by map area or by location. Filter by holes, access, price range, difficulty, facilities, and vibe. No live availability or price guarantees." name="twitter:description"/><script type="application/ld+json">[{"@context": "https://schema.org", "@type": "WebPage", "name": "Search golf courses", "url": "https://golfdonebetter.com/search-courses", "isPartOf": {"@type": "WebSite", "name": "Golf Done Better", "url": "https://golfdonebetter.com/"}, "description": "Search golf courses by map area or by location. Filter by holes, access, price range, difficulty, facilities, and vibe. No live availability or price guarantees."}]</script>  <link rel="icon" href="favicon.ico">
<script>window.$ = window.$ || ((id) => document.getElementById(id));</script>
</head>
<body><a class="skip-link" href="#main">Skip to main content</a>
<header>
<div class="header-inner">
<a aria-label="GDB home" href="#" style="display:flex;align-items:center;gap:14px;">
<svg aria-label="GDB logo" height="40" role="img" viewbox="0 0 420 120" width="132">
<text fill="#ffffff" font-family="Libre Baskerville, Georgia, serif" font-size="72" font-weight="700" letter-spacing="-1.5" text-anchor="middle" x="210" y="70">GDB</text>
<text fill="#ffffff" font-family="Libre Baskerville, Georgia, serif" font-size="18" letter-spacing="1.6" opacity="0.9" text-anchor="middle" x="210" y="104">Golf Done Better</text>
</svg>
</a>
<div aria-label="Site menu" class="page-menu">
<button aria-expanded="false" aria-haspopup="true" aria-label="Open menu" class="menu-btn" id="menuBtn" type="button">
<svg aria-hidden="true" fill="none" height="22" viewbox="0 0 24 24" width="22">
<path d="M4 7h16M4 12h16M4 17h16" stroke="currentColor" stroke-linecap="round" stroke-width="2.4"></path>
</svg>
</button>
<div aria-label="Navigation" class="menu-panel" id="menuPanel" role="menu">
<a href="index.html" role="menuitem">Home page</a>
<a href="search-courses.html" role="menuitem">Search courses</a>
<a href="plan-golf-trip.html" role="menuitem">Plan a golf trip</a>
<div class="menu-sep"></div>
<a href="about.html" role="menuitem">About us</a>
<a href="contact.html" role="menuitem">Contact us</a>
<a href="terms.html" role="menuitem">Terms and conditions</a>
</div>
</div>
</div>
</header>
<main class="wrap" id="main">
<section class="intro" style="text-align:center">
<h1 style="font-size:30px">Search Courses</h1>
<p>Pick a search tool, filter results, review and compare courses.</p>
</section>
<section aria-label="Search mode" class="modes">
<button class="btn" data-mode="map" id="btnMap" type="button">Map Search</button>
<button class="btn" data-mode="text" id="btnText" type="button">Text Search</button>
<button class="btn" data-mode="near" id="btnNear" type="button">Find Courses Near Me</button>
<div class="prompt" id="modePrompt">Select a search mode to begin.</div>
</section>
<div class="layout" id="pageLayout">
<div class="maincol" id="mainCol">
<section aria-label="Text Search" class="text-search" id="textSearch">
<div class="textbar">
<div class="acwrap">
<input autocomplete="off" id="textQuery" placeholder="Search by address, postcode, city, region, country or course name" type="text"/>
<div aria-label="Search suggestions" class="ac-panel" id="acPanel"></div>
</div>
<select aria-label="Search radius" id="radiusSelect">
<option value="0">Exact</option>
<option selected="" value="5">5 miles</option>
<option value="10">10 miles</option>
<option value="25">25 miles</option>
<option value="50">50 miles</option>
</select>
<button class="btn" id="textGo" type="button">Search</button>
</div>
</section>
<div id="mapWrap">
<div class="live-pill" id="livePill">Select an area to load golf data</div>
<button class="map-clear" id="clearAreaBtn" type="button">Clear area</button>
<button class="map-reset" id="resetViewBtn" type="button">Reset view</button>
<div class="map-instruction" id="drawGuide">Select a drawing tool, then mark an area to load golf data</div>
<div id="map"></div>
<div aria-label="Selected course quick view" class="map-sidepanel" id="mapSidePanel">
<div class="map-sidepanel-header">
<div class="map-sidepanel-title">Selected course</div>
<button aria-label="Close" class="map-sidepanel-close" id="closeSidePanel" type="button">✕</button>
</div>
<div class="map-sidepanel-body" id="mapSidePanelBody"></div>
</div>
</div>
<div class="sort-row" id="sortRow">
<div class="hint"><strong>Results shown:</strong> <span id="courseCount">0</span></div>
<div style="display:flex;gap:14px;align-items:center;flex-wrap:wrap">
<div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
<label class="hint" for="sortSelect">Sort</label>
<select id="sortSelect">
<option value="recommended">Recommended</option>
<option selected="" value="az">A–Z</option>
<option value="priceAsc">Price low to high</option>
<option value="priceDesc">Price high to low</option>
<option value="holesDesc">Most holes</option>
<option value="difficultyAsc">Easiest first</option>
<option value="savedFirst">Saved first</option>
</select>
</div>
<div aria-label="Result types" class="type-toggles">
<div class="tlabel">Show</div>
<label class="tchip disabled"><input checked="" disabled="" type="checkbox"/> ⛳ Courses</label>
</div>
</div>
</div>
<section class="results" id="resultsSection">
<h2>Courses in this area</h2>
<div id="resultsList"></div>
</section>
</div>
<aside class="sidecol" id="sideCol" style="display:none">
<section aria-label="Filters" class="filters-wrap" id="filtersWrap" style="display:none">
<div class="filters-bar">
  <div class="filters-left">
    <div class="filters-actions">
      <button class="btn" id="clearFiltersBtn" style="padding:10px 12px;border-radius:10px;" type="button">Clear filters</button>
      <button class="btn" id="applyFiltersBtnTop" style="padding:10px 12px;border-radius:10px;" type="button">Apply filters</button>
    </div>
    <div class="chip chip-static" id="toggleFilters">Filters <span class="chip-count" id="activeFilterCount">0</span></div>
    <div class="smallhint" id="selectAreaHint">Select an area first, then filter results</div>
  </div>
</div>
<div class="filters-panel" id="filtersPanel" style="display:block">
<div class="filters-panel-inner">
<details class="acc" open="">
  <summary><span class="sum-left">Holes</span><span class="sum-pill" data-pill="holes">Any</span></summary>
  <div class="acc-body">
    <div class="fopts" id="fHoles">
      <label class="fopt"><input type="checkbox" value="9"/> 9</label>
      <label class="fopt"><input type="checkbox" value="18"/> 18</label>
      <label class="fopt"><input type="checkbox" value="27"/> 27</label>
      <label class="fopt"><input type="checkbox" value="36plus"/> 36 plus</label>
    </div>
  </div>
</details>

<details class="acc">
  <summary><span class="sum-left">Access</span><span class="sum-pill" data-pill="access">Any</span></summary>
  <div class="acc-body">
    <div class="fopts" id="fAccess">
      <label class="fopt"><input type="checkbox" value="public"/> Public</label>
      <label class="fopt"><input type="checkbox" value="visitors"/> Visitors</label>
      <label class="fopt"><input type="checkbox" value="members_only"/> Members only</label>
    </div>
  </div>
</details>

<details class="acc">
  <summary><span class="sum-left">Price band</span><span class="sum-pill" data-pill="price_band">Any</span></summary>
  <div class="acc-body">
    <div class="fopts" id="fPriceBand">
      <label class="fopt"><input type="checkbox" value="value"/> Value</label>
      <label class="fopt"><input type="checkbox" value="mid"/> Mid</label>
      <label class="fopt"><input type="checkbox" value="premium"/> Premium</label>
      <label class="fopt"><input type="checkbox" value="luxury"/> Luxury</label>
    </div>
  </div>
</details>

<details class="acc">
  <summary><span class="sum-left">Difficulty</span><span class="sum-pill" data-pill="difficulty">Any</span></summary>
  <div class="acc-body">
    <div class="fopts" id="fDifficulty">
      <label class="fopt"><input type="checkbox" value="easy"/> Easy</label>
      <label class="fopt"><input type="checkbox" value="medium"/> Intermediate</label>
      <label class="fopt"><input type="checkbox" value="hard"/> Hard</label>
      <label class="fopt"><input type="checkbox" value="pro"/> Pro</label>
      <label class="fopt"><input type="checkbox" value="championship"/> Championship</label>
    </div>
  </div>
</details>

<details class="acc">
  <summary><span class="sum-left">Dress code</span><span class="sum-pill" data-pill="dress_code">Any</span></summary>
  <div class="acc-body">
    <div class="fopts" id="fDressCode">
      <label class="fopt"><input type="checkbox" value="relaxed"/> Relaxed</label>
      <label class="fopt"><input type="checkbox" value="smart_casual"/> Smart casual</label>
      <label class="fopt"><input type="checkbox" value="strict"/> Strict</label>
    </div>
  </div>
</details>

<details class="acc">
  <summary><span class="sum-left">Vibe</span><span class="sum-pill" data-pill="vibe">Any</span></summary>
  <div class="acc-body">
    <div class="fopts" id="fVibe">
      <label class="fopt"><input type="checkbox" value="friendly"/> Friendly</label>
      <label class="fopt"><input type="checkbox" value="relaxed"/> Relaxed</label>
      <label class="fopt"><input type="checkbox" value="premium"/> Premium</label>
      <label class="fopt"><input type="checkbox" value="traditional"/> Traditional</label>
    </div>
  </div>
</details>

<details class="acc">
  <summary><span class="sum-left">Facilities</span><span class="sum-pill" data-pill="facilities">Any</span></summary>
  <div class="acc-body">
    <div class="fopts" id="fFacilities" style="grid-template-columns:repeat(2,minmax(0,1fr));gap:10px;">
      <label class="fopt"><input type="checkbox" value="driving_range"/> Driving range</label>
      <label class="fopt"><input type="checkbox" value="practice_area"/> Practice areas</label>
      <label class="fopt"><input type="checkbox" value="buggies"/> Buggies</label>
      <label class="fopt"><input type="checkbox" value="trollies"/> Trollies</label>
      <label class="fopt"><input type="checkbox" value="restaurant"/> Restaurant</label>
      <label class="fopt"><input type="checkbox" value="bar"/> Bar</label>
      <label class="fopt"><input type="checkbox" value="pro_shop"/> Pro shop</label>
      <label class="fopt"><input type="checkbox" value="club_hire"/> Clubs for hire</label>
      <label class="fopt"><input type="checkbox" value="lessons"/> Lessons</label>
      <label class="fopt"><input type="checkbox" value="showers"/> Showers</label>
    </div>
  </div>
</details>

<details class="acc">
  <summary><span class="sum-left">Extras</span><span class="sum-pill" data-pill="extras">Any</span></summary>
  <div class="acc-body">
    <div class="fopts" id="fExtras">
      <label class="fopt"><input type="checkbox" value="alcohol_allowed"/> Alcohol allowed on course</label>
      <label class="fopt"><input type="checkbox" value="smoking_allowed"/> Smoking allowed on course</label>
    </div>
  </div>
</details>

<details class="acc">
  <summary><span class="sum-left">Course type</span><span class="sum-pill" data-pill="course_type">Any</span></summary>
  <div class="acc-body">
    <div class="fopts" id="fCourseType">
      <label class="fopt"><input type="checkbox" value="links"/> Links</label>
      <label class="fopt"><input type="checkbox" value="parkland"/> Parkland</label>
      <label class="fopt"><input type="checkbox" value="heathland"/> Heathland</label>
      <label class="fopt"><input type="checkbox" value="moorland"/> Moorland</label>
      <label class="fopt"><input type="checkbox" value="resort"/> Resort</label>
      <label class="fopt"><input type="checkbox" value="standard"/> Standard</label>
    </div>
  </div>
</details>
</div></div>
<div class="filters-footer-actions">
<div class="filters-actions-row">
<button class="btn" id="clearFiltersBtnBottom" style="padding:10px 12px;border-radius:10px;" type="button">Clear filters</button>
<button class="btn" id="applyFiltersBtn" style="padding:10px 12px;border-radius:10px;" type="button">Apply filters</button>
</div>
</div>
</section>
</aside>
</div>
<!-- /maincol -->
<!-- /layout -->
</main>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const ensureLeaflet = () => {
    if(window.L && window.L.map) return true;
    const wrap = $('mapWrap');
    const mapEl = $('map');
    if(wrap) wrap.style.display = 'block';
    if(mapEl){
      mapEl.innerHTML = '<div style="padding:18px;line-height:1.35;border:1px solid rgba(255,255,255,.16);border-radius:14px;background:rgba(255,255,255,.04);margin:12px;">'
        + '<div style="font-weight:900;margin-bottom:6px;">Map library not loaded</div>'
        + '<div style="opacity:.85;">This page loads Leaflet from a public CDN. If your viewer blocks network requests, the map will not run. Download the file and open it in a browser with internet access. If needed, open via a simple local web server.</div>'
        + '</div>';
    }
    // Keep the rest of the UI usable, but Map Search will not function without Leaflet.
    return false;
  };


  const escapeHtml = (s) => String(s ?? '')
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');

  const isFileOrigin = (location && location.protocol === 'file:');

  const saved = new Set(JSON.parse(localStorage.getItem('gdb_saved') || '[]'));
  const saveSaved = () => localStorage.setItem('gdb_saved', JSON.stringify([...saved]));

  // --- Compare shortlist (max 6) ---
  window.compareSet = window.compareSet || new Set(JSON.parse(localStorage.getItem('gdb_compare') || '[]'));
  const compareSet = window.compareSet;
  const saveCompare = () => localStorage.setItem('gdb_compare', JSON.stringify([...compareSet]));
  window.saveCompare = saveCompare;
  window.compareMax = window.compareMax || 6;
  const compareMax = window.compareMax;
  let lastRenderedList = [];
  let currentResults = [];
    window.currentResults = currentResults;
    // Cache dataset for Full Details page (local use)
    try{
      if (Array.isArray(GDB_COURSES) && GDB_COURSES.length){
        localStorage.setItem('GDB_COURSES_CACHE_V1', JSON.stringify(GDB_COURSES));
      }
    }catch(e){}

  window.currentResults = currentResults;

  const toast = (msg, dur=2800) => {
    const t = document.getElementById('gdbToast');
    if(!t) return;
    t.textContent = msg;
    t.classList.add('show');
    clearTimeout(window.__gdbToastTimer);
    window.__gdbToastTimer = setTimeout(() => t.classList.remove('show'), dur);
  };
  window.toast = toast;


  const updateCompareUi = () => {
    // Buttons on cards
    document.querySelectorAll('[data-compare]').forEach(btn => {
      const id = btn.getAttribute('data-compare');
      const on = id && compareSet.has(id);
      btn.classList.toggle('on', !!on);
      btn.setAttribute('aria-pressed', on ? 'true' : 'false');
    });

    // Widget
    const w = document.getElementById('compareWidget');
    const c = document.getElementById('compareCount');
    if(c) c.textContent = String(compareSet.size);
    if(w){
      w.style.display = (compareSet.size >= 2) ? 'flex' : 'none';
    }

    // Repaint markers immediately
    if(typeof renderMarkers === 'function' && Array.isArray(lastRenderedList)){
      renderMarkers(lastRenderedList);
    }
  };
  window.updateCompareUi = updateCompareUi;


  const toggleCompare = (id) => {
    if(!id) return;

    if(compareSet.has(id)){
      compareSet.delete(id);
      saveCompare();
      updateCompareUi();
      return;
    }

    if(compareSet.size >= compareMax){
      toast(`You can compare up to ${compareMax} courses`, 1200);
      return;
    }

    compareSet.add(id);
    saveCompare();

    if(compareSet.size === 1){
      toast('Select at least 2 courses to compare');
    }
    updateCompareUi();
  };

  // Event delegation so popups and re-rendered cards work without extra wiring
  document.addEventListener('click', (e) => {
    const btn = e.target && e.target.closest ? e.target.closest('[data-compare]') : null;
    if(!btn) return;
    e.preventDefault();
    e.stopPropagation();
    const id = btn.getAttribute('data-compare');
    toggleCompare(id);
  }, true);



    // --- Local GDB dataset (loaded from /data) ---
  let GDB_COURSES = [];
  let GDB_READY = false;
  let GDB_ALL = [];
  let GDB_BY_ID = null;

  const loadGdbLocal = async () => {
    if(GDB_READY) return true;
    try{
      const cRes = await fetch('data/gdb_courses_uk.json', {cache:'no-store'});
const cJson = await cRes.json();      GDB_COURSES = (cJson.courses || []).filter(x => x && x.geo && Number.isFinite(x.geo.lat) && Number.isFinite(x.geo.lng));
      // Debug hook
      window.gdbDebug = {
        loaded:true,
        coursesCount:GDB_COURSES.length,
        rangesCount:0,
        sampleCourse:GDB_COURSES[0] || null,
      };

      GDB_READY = true;
      return true;
    } catch(e){
      window.gdbDebug = { loaded:false, error:String(e) };
      return false;
    }
  };

  const normalizeCourse = (c) => {
    const city = (c.address && c.address.city && c.address.city !== 'unknown') ? c.address.city : '';
    const website = c.links && c.links.official && c.links.official !== 'unknown' ? c.links.official : '';
    const accessRaw = (Array.isArray(c.access) ? c.access[0] : c.access) || 'unknown';
    const access = accessRaw === 'visitors_welcome' ? 'visitors' : accessRaw === 'members_only' ? 'members_only' : accessRaw === 'public' ? 'public' : 'unknown';

    const vibeRaw = Array.isArray(c.vibe) ? c.vibe : [];
    const vibe = vibeRaw
      .filter(v => v && v !== 'beginner_friendly')
      .map(v => v === 'beginner_friendly' ? 'friendly' : v);
    // Ensure anything tagged beginner_friendly is also friendly (for filters)
    if(vibeRaw.includes('beginner_friendly') && !vibe.includes('friendly')) vibe.push('friendly');

    const diffRaw = Array.isArray(c.difficulty) ? c.difficulty : [];
    const diff = [...diffRaw];
    // Offer overlap: beginner friendly vibe implies easy
    if(vibeRaw.includes('beginner_friendly') && !diff.includes('easy')) diff.push('easy');
    // Championship implies pro overlap
    if(diffRaw.includes('championship') && !diff.includes('pro')) diff.push('pro');

    const dcRaw = Array.isArray(c.dress_code) ? c.dress_code : [];
    const dress = dcRaw.map(x => x === 'strict_golf_attire' ? 'strict' : x);

    const pbRaw = Array.isArray(c.price_band) ? c.price_band[0] : c.price_band;
    const price_band = (pbRaw && pbRaw !== 'unknown') ? pbRaw : 'unknown';

    const ct = Array.isArray(c.course_type) ? c.course_type : [];

    const fac = Array.isArray(c.facilities) ? c.facilities : [];
    const exRaw = Array.isArray(c.extras) ? c.extras : [];
    // Map legacy unknown extras to empty (unknown)
    const ex = exRaw.filter(x => x === 'alcohol_allowed' || x === 'smoking_allowed');

    return {
      id: c.id,
      kind: 'course',
      name: c.name,
      city,
      place: city,
      lat: c.geo.lat,
      lng: c.geo.lng,
      holes: Array.isArray(c.holes) ? (c.holes[0] || 0) : (Number(c.holes) || 0),
      par: c.par,
      access,
      price_band,
      difficulty: diff,
      dress_code: dress,
      vibe,
      course_type: ct,
      facilities: fac,
      extras: ex,
      website,
      source: c.source || {}
    };
  };

  
const fs = {holes:new Set(),access:new Set(),price_band:new Set(),difficulty:new Set(),dress_code:new Set(),vibe:new Set(),facilities:new Set(),extras:new Set(),course_type:new Set()};

  let mode = null;
  let sort = 'az';
  let geom = null;
  let geomAreaId = null; // Overpass area id for large admin boundaries (relation id + 3600000000)

  let map=null, markers=null, drawn=null, clickCircle=null, drawControl=null;

  let mapToolArmed = false; // map mode: hide live pill until a draw tool is selected

  const HOME_VIEW = { center:[54.5,-3], zoom:6 };

  let liveItems = [];
  let liveStatus = 'idle';
  let liveAbort = null;
  const visibleKinds = new Set(['course']);

  const PLACEHOLDER_IMG = 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="640" height="420" viewBox="0 0 640 420">\n  <defs>\n    <linearGradient id="g" x1="0" x2="1" y1="0" y2="1">\n      <stop offset="0" stop-color="#153126" />\n      <stop offset="1" stop-color="#0b1713" />\n    </linearGradient>\n  </defs>\n  <rect width="640" height="420" fill="url(#g)"/>\n  <g fill="#ffffff" opacity="0.78" font-family="Arial, Helvetica, sans-serif" font-weight="900">\n    <text x="50%" y="48%" font-size="28" text-anchor="middle">Golf Done Better</text>\n    <text x="50%" y="58%" font-size="14" text-anchor="middle" opacity="0.75">Image loading</text>\n  </g>\n</svg>`);
  // Expose for inline onerror handlers
  window.PLACEHOLDER_IMG = PLACEHOLDER_IMG;


  const imageCache = new Map();


  const cacheLastResults = (items) => {
    try{
      const slim = (items || []).map(x => ({
        id:x.id, kind:x.kind, name:x.name, place:x.place, lat:x.lat, lng:x.lng,
        holes:x.holes, par:x.par, lengthM:x.lengthM, priceLow:x.priceLow, priceHigh:x.priceHigh,
        access:x.access, style:x.style, vibe:x.vibe, facilities:x.facilities, difficulty:x.difficulty,
        walkability:x.walkability, accommodation:x.accommodation,
        summary:x.summary, description:x.description,
        tags:x.tags || {},
        imageUrl: (typeof imageCache !== 'undefined' && imageCache.has(x.id)) ? (imageCache.get(x.id) || '') : ''
      }));
      localStorage.setItem('gdb_last_results', JSON.stringify(slim));
    } catch(e){}
  };


  const setLivePill = (text) => {
    const pill = $('livePill');
    if(pill) pill.textContent = text;
    const note = $('liveNote');
    if(note) note.style.display = isFileOrigin ? 'block' : 'none';
  };

  const idlePillText = () => (mode === 'text') ? 'Type a location to load golf data' : 'Select an area to load golf data';

  const titleCase = (x) => {
    const s = String(x || '').replace(/_/g,' ').trim();
    if(!s) return '';
    return s.split(' ').filter(Boolean).map(w => w.slice(0,1).toUpperCase() + w.slice(1)).join(' ');
  };
  const labels = (arr) => (arr || []).map(x => x === 'hiddenGem' ? 'Hidden gem' : titleCase(x));

  const midPrice = (c) => {
    const lo = Number(c.priceLow || 0);
    const hi = Number(c.priceHigh || lo);
    if(!lo && !hi) return Infinity;
    return (lo + hi) / 2;
  };
  const priceLabel = (c) => {
    const lo = Number(c.priceLow || 0);
    const hi = Number(c.priceHigh || 0);
    if(!lo && !hi) return 'Price unknown';
    if(lo && hi && lo !== hi) return `£${lo} to £${hi}`;
    return `£${lo || hi}`;
  };
  const priceBucket = (c) => {
    const m = midPrice(c);
    if(!Number.isFinite(m)) return 'unknown';
    if(m < 60) return 'under60';
    if(m < 120) return '60to120';
    if(m < 200) return '120to200';
    return '200plus';
  };

  const countFilters = () => Object.values(fs).reduce((n,s)=>n+(s.size||0),0);
  const setCount = () => { const el=$('activeFilterCount'); if(el) el.textContent=String(countFilters()); };

  const updatePills = () => {
    const setPill = (key, label) => {
      const el = document.querySelector('[data-pill="' + key + '"]');
      if(!el) return;
      const s = fs[key];
      if(!s || !s.size) { el.textContent = 'Any'; return; }
      if(label) { el.textContent = label(s); return; }
      el.textContent = s.size + ' selected';
    };
    setPill('holes', (s)=> {
      if(s.has('36plus') && s.size===1) return '36 plus';
      const vals = Array.from(s).map(v => v==='36plus' ? '36 plus' : v).sort((a,b)=> (a+'').localeCompare(b+''));
      return vals.join(', ');
    });
    setPill('access', (s)=> Array.from(s).map(v => v==='members_only' ? 'Members only' : (v==='visitors'?'Visitors':'Public')).join(', '));
    setPill('price_band', (s)=> Array.from(s).map(v => titleCase(v)).join(', '));
    setPill('difficulty', (s)=> Array.from(s).map(v => v==='medium' ? 'Intermediate' : titleCase(v)).join(', '));
    setPill('dress_code', (s)=> Array.from(s).map(v => v==='smart_casual' ? 'Smart casual' : titleCase(v)).join(', '));
    setPill('vibe', (s)=> Array.from(s).map(v => titleCase(v)).join(', '));
    setPill('facilities', (s)=> s.size + ' selected');
    setPill('extras', (s)=> s.size + ' selected');
    setPill('course_type', (s)=> s.size + ' selected');
  };

  const readChecks = () => {
    const group = (gid,key) => {
      fs[key].clear();
      document.querySelectorAll('#' + gid + ' input[type="checkbox"]:checked').forEach(cb => fs[key].add(cb.value));
    };
    group('fHoles','holes');
    group('fAccess','access');
    group('fPriceBand','price_band');
    group('fDifficulty','difficulty');
    group('fDressCode','dress_code');
    group('fVibe','vibe');
    group('fFacilities','facilities');
    group('fExtras','extras');
    group('fCourseType','course_type');
  };

  const clearFilters = () => {
    document.querySelectorAll('#filtersPanel input[type="checkbox"]').forEach(cb => cb.checked=false);
    Object.keys(fs).forEach(k => fs[k].clear());
    setCount();
    updatePills();
    refresh();
  };

  const applyFilters = () => {
    readChecks();
    setCount();
    updatePills();
    refresh();
  };

  const passes = (c) => {
    const any = (s) => s && s.size>0;
    const inter = (arr,s) => Array.isArray(arr) && arr.some(x => s.has(x));

    // Holes: unknown should not be excluded
    if(any(fs.holes)){
      const h = Number(c.holes || 0);
      if(!h) {
        // unknown holes, keep it visible
      } else {
        const b = (h>=36) ? '36plus' : String(h);
        if(!fs.holes.has(b)) return false;
      }
    }

    // Access: unknown should not be excluded
    if(any(fs.access)){
      const a = String(c.access || 'unknown');
      if(a !== 'unknown' && !fs.access.has(a)) return false;
    }

    // Price band: unknown should not be excluded
    if(any(fs.price_band)){
      const pb = String(c.price_band || 'unknown');
      if(pb !== 'unknown' && !fs.price_band.has(pb)) return false;
    }

    // Difficulty: treat unknown as pass
    if(any(fs.difficulty)){
      const d = c.difficulty || [];
      if(d.length){
        if(!inter(d, fs.difficulty)) return false;
      }
    }

    // Dress code: unknown as pass
    if(any(fs.dress_code)){
      const dc = c.dress_code || [];
      if(dc.length){
        if(!inter(dc, fs.dress_code)) return false;
      }
    }

    // Vibe
    if(any(fs.vibe)){
      const v = c.vibe || [];
      if(v.length){
        if(!inter(v, fs.vibe)) return false;
      }
    }

    // Course type
    if(any(fs.course_type)){
      const ct = c.course_type || [];
      if(ct.length){
        if(!inter(ct, fs.course_type)) return false;
      }
    }

    // Facilities: require known match, but do not exclude unknown
    if(any(fs.facilities)){
      const f = c.facilities || [];
      if(f.length){
        for(const need of fs.facilities) if(!f.includes(need)) return false;
      }
    }

    // Extras: same rule as facilities
    if(any(fs.extras)){
      const ex = c.extras || [];
      if(ex.length){
        for(const need of fs.extras) if(!ex.includes(need)) return false;
      }
    }

    return true;
  };

  const pointIn = (c) => {
    if(!geom) return true;
    const pt = turf.point([c.lng, c.lat]);
    const poly = turf.geometry(geom.type, geom.coordinates);
    return turf.booleanPointInPolygon(pt, poly);
  };

  const sortList = (list) => {
    const alpha = (a,b) => (a.name||'').localeCompare(b.name||'');

    const hasAny = (arr) => Array.isArray(arr) && arr.length > 0;

    const recommendedScore = (c) => {
      let s = 0;

      const holes = Number(c.holes || 0);
      if(holes >= 18) s += 40;
      if(holes >= 27) s += 10;
      if(holes >= 36) s += 6;
      if(holes > 0 && holes < 9) s -= 30;

      const access = String(c.access || '').toLowerCase();
      if(access === 'public') s += 12;
      else if(access === 'visitor') s += 10;
      else if(access === 'members') s -= 8;

      const facilities = Array.isArray(c.facilities) ? c.facilities.length : 0;
      s += Math.min(18, facilities * 2);

      if(c.tags){
        const t = c.tags;
        const website = String(t.website || t['contact:website'] || t.url || '').trim();
        if(website && /^https?:\/\//i.test(website)) s += 12;

        const phone = String(t.phone || t['contact:phone'] || '').trim();
        if(phone) s += 3;

        const email = String(t.email || t['contact:email'] || t['email:booking'] || '').trim();
        if(email) s += 3;

        const wiki = String(t.wikipedia || '').trim();
        if(wiki) s += 6;

        const wd = String(t.wikidata || '').trim();
        if(wd) s += 6;
      }

      if(hasAny(c.vibe)){
        const v = new Set(c.vibe);
        if(v.has('premium')) s += 6;
        if(v.has('championship')) s += 6;
        if(v.has('hiddenGem')) s += 4;
        if(v.has('family')) s += 2;
        if(v.has('casual')) s += 1;
      }

      if(hasAny(c.difficulty)){
        const d = new Set(c.difficulty);
        if(d.has('medium')) s += 2;
        if(d.has('easy')) s += 1;
        if(d.has('hard')) s -= 1;
        if(d.has('pro')) s -= 2;
      }

      const img = (typeof imageCache !== 'undefined' && imageCache.has(c.id)) ? (imageCache.get(c.id) || '') : '';
      if(img) s += 3;

      return s;
    };

    if(sort === 'recommended'){
      return [...list].sort((a,b) => (recommendedScore(b) - recommendedScore(a)) || alpha(a,b));
    }
    if(sort === 'az') return [...list].sort(alpha);
    if(sort === 'priceAsc') return [...list].sort((a,b)=>midPrice(a)-midPrice(b) || alpha(a,b));
    if(sort === 'priceDesc') return [...list].sort((a,b)=>midPrice(b)-midPrice(a) || alpha(a,b));
    if(sort === 'holesDesc') return [...list].sort((a,b)=>(b.holes||0)-(a.holes||0) || alpha(a,b));
    if(sort === 'difficultyAsc'){
      const score = (x) => (x.difficulty||[]).includes('easy')?1:(x.difficulty||[]).includes('medium')?2:(x.difficulty||[]).includes('hard')?3:(x.difficulty||[]).includes('pro')?4:99;
      return [...list].sort((a,b)=>score(a)-score(b) || alpha(a,b));
    }
    if(sort === 'savedFirst'){
      return [...list].sort((a,b)=>(saved.has(a.id)?0:1)-(saved.has(b.id)?0:1) || alpha(a,b));
    }
    return [...list].sort(alpha);
  };

  const kindLabel = (k) => (k==='range') ? 'Driving range' : 'Course';
  const kindEmoji = (k) => (k==='range') ? '🏌️' : '⛳';

  const markerIcon = (k, isCompared=false) => {
    const bg = isCompared ? 'rgba(212,175,55,.95)' : 'rgba(11,23,19,.78)';
    const bd = isCompared ? 'rgba(212,175,55,.95)' : 'rgba(255,255,255,.25)';
    const fg = isCompared ? '#0b1713' : '#ffffff';
    return L.divIcon({
      className:'',
      html:`<div aria-label="${kindLabel(k)}" title="${kindLabel(k)}" style="width:30px;height:30px;border-radius:999px;background:${bg};border:1px solid ${bd};display:flex;align-items:center;justify-content:center;font-size:16px;color:${fg};font-weight:900;box-shadow:${isCompared ? "0 0 0 3px rgba(212,175,55,.35), 0 12px 26px rgba(0,0,0,.40)" : "0 10px 22px rgba(0,0,0,.32)"}">${kindEmoji(k)}</div>`,
      iconSize:[30,30],
      iconAnchor:[15,15]
    });
  };

  const normalizeWikiTitle = (s) => String(s||'').replace(/_/g,' ').trim();

  // NOTE: When the page is opened via file:// (origin "null"), some REST endpoints can fail CORS.
  // We use the MediaWiki API with origin=* wherever possible to keep images working locally.

  const wikipediaThumbFromTag = async (wikipediaTag) => {
    const raw = String(wikipediaTag||'');
    const parts = raw.split(':');
    if(parts.length < 2) return null;
    const lang = parts.shift();
    const title = normalizeWikiTitle(parts.join(':'));
    if(!lang || !title) return null;

    const api = `https://${lang}.wikipedia.org/w/api.php?origin=*`;
    const url = `${api}&action=query&prop=pageimages&piprop=thumbnail|original&pithumbsize=900&titles=${encodeURIComponent(title)}&format=json`;
    const res = await fetch(url, { headers:{ 'accept':'application/json' } });
    if(!res.ok) return null;
    const data = await res.json();
    const pages = Object.values(data?.query?.pages || {});
    const p = pages?.[0];
    return p?.thumbnail?.source || p?.original?.source || null;
  };

  const wikidataP18 = async (qid) => {
    const q = String(qid||'').trim();
    if(!q) return null;
    const url = `https://www.wikidata.org/w/api.php?origin=*&action=wbgetentities&ids=${encodeURIComponent(q)}&props=claims&format=json`;
    const res = await fetch(url, { headers:{ 'accept':'application/json' } });
    if(!res.ok) return null;
    const data = await res.json();
    const ent = data?.entities?.[q];
    const p18 = ent?.claims?.P18?.[0]?.mainsnak?.datavalue?.value;
    if(!p18) return null;
    const file = String(p18).replace(/^File:/i,'').trim();
    if(!file) return null;
    return `https://commons.wikimedia.org/wiki/Special:FilePath/${encodeURIComponent(file)}?width=900`;
  };

  const wikiSearchThumb = async (name, place, lat, lng) => {
    const qName = String(name || '').trim();
    if(!qName) return null;

    const tokens = (s) => String(s||'')
      .toLowerCase()
      .replace(/[^a-z0-9 ]+/g,' ')
      .split(' ')
      .filter(Boolean)
      .filter(w => w.length > 2);

    const overlapScore = (a, b) => {
      const A = new Set(tokens(a));
      const B = new Set(tokens(b));
      if(!A.size || !B.size) return 0;
      let hit = 0;
      for(const w of A) if(B.has(w)) hit++;
      return hit / Math.max(1, Math.min(A.size, B.size));
    };

    const haversineKm = (aLat,aLng,bLat,bLng) => {
      const toRad = (d) => d * Math.PI / 180;
      const R = 6371;
      const dLat = toRad(bLat - aLat);
      const dLng = toRad(bLng - aLng);
      const s1 = Math.sin(dLat/2), s2 = Math.sin(dLng/2);
      const aa = s1*s1 + Math.cos(toRad(aLat))*Math.cos(toRad(bLat))*s2*s2;
      return 2 * R * Math.asin(Math.min(1, Math.sqrt(aa)));
    };

    const query = [qName, place, 'golf'].filter(Boolean).join(' ');
    const searchUrl = `https://en.wikipedia.org/w/api.php?origin=*&action=query&list=search&srsearch=${encodeURIComponent(query)}&srlimit=5&format=json`;
    const sRes = await fetch(searchUrl, { headers:{ 'accept':'application/json' } });
    if(!sRes.ok) return null;
    const sData = await sRes.json();

    const results = (sData?.query?.search || [])
      .map(x => ({ title: x?.title, score: overlapScore(qName, x?.title) }))
      .filter(x => x.title && x.score >= 0.50)
      .sort((a,b) => b.score - a.score)
      .slice(0, 3);

    if(!results.length) return null;

    // Pull coordinates + thumbnails for the short list
    const titles = results.map(r => r.title).map(encodeURIComponent).join('|');
    const pageUrl = `https://en.wikipedia.org/w/api.php?origin=*&action=query&prop=pageimages|coordinates|description&piprop=thumbnail|original&pithumbsize=900&pilimit=3&titles=${titles}&format=json`;
    const pRes = await fetch(pageUrl, { headers:{ 'accept':'application/json' } });
    if(!pRes.ok) return null;
    const pData = await pRes.json();
    const pages = Object.values(pData?.query?.pages || {});

    const scored = pages.map(p => {
      const title = p?.title || '';
      const oScore = overlapScore(qName, title);
      const desc = String(p?.description || '').toLowerCase();
      const isGolfy = !desc || desc.includes('golf') || desc.includes('links') || desc.includes('club');
      const c = p?.coordinates?.[0];
      let dist = null;
      if(c && Number.isFinite(lat) && Number.isFinite(lng)) {
        dist = haversineKm(lat, lng, c.lat, c.lon);
      }
      return {
        title,
        oScore,
        isGolfy,
        dist,
        thumb: p?.thumbnail?.source || p?.original?.source || null,
      };
    })
    .filter(x => x.thumb)
    .filter(x => x.oScore >= 0.50)
    .filter(x => x.isGolfy);

    if(!scored.length) return null;

    // Prefer nearby matches when we have coords
    scored.sort((a,b) => {
      const ad = (a.dist==null)? 9999 : a.dist;
      const bd = (b.dist==null)? 9999 : b.dist;
      if(ad !== bd) return ad - bd;
      return b.oScore - a.oScore;
    });

    const best = scored[0];
    if(best.dist != null) {
      // Keep it tight to avoid random course photos
      if(best.dist > 20) return null;
    }

    return best.thumb;
  };

  

  const resolveImage = async (item) => {
    const t = item?.tags || {};

    // 1) Strongest signal: Wikidata -> Commons image (P18)
    const qid = (t.wikidata || '').trim();
    if(qid && /^Q\d+$/i.test(qid)){
      try{
        const u = await wikidataP18(qid);
        if(u) return u;
      } catch(e) {}
    }

    // 2) Direct image URL in OSM tags (only if it looks like an actual image)
    const direct = t.image || t.thumbnail || t['image:0'] || null;
    if(direct && /^https?:\/\//i.test(direct) && /\.(png|jpe?g|webp)(\?.*)?$/i.test(direct)) return direct;

    // 3) Wikimedia Commons file tagging
    const wc = t.wikimedia_commons || t['wikimedia_commons:en'] || null;
    if(wc){
      const s = String(wc).trim();
      const file = s.replace(/^File:/i,'').replace(/^Category:/i,'').trim();
      // If it is a file, we can turn it into a thumbnail. If it is a category, skip here and fall back to wikipedia.
      if(file && !/^Category:/i.test(s)){
        return 'https://commons.wikimedia.org/wiki/Special:FilePath/' + encodeURIComponent(file) + '?width=800';
      }
    }

    // 4) Wikipedia page summary thumbnail (often best match if the course has a page)
    const wp = t.wikipedia || null;
    if(wp){
      const [lang, titleRaw] = String(wp).split(':');
      const title = (titleRaw || '').trim();
      const l = (lang || 'en').trim();
      if(title){
        try{
          const u = await wikipediaThumbFromTag(`${l}:${title}`);
          if(u) return u;
        } catch(e) {}
      }
    }

    // 5) Fallback: Wikipedia search by name and location, then validate by proximity.
    // This is the approach that tends to work best for OSM objects that do not carry wikipedia/wikidata tags.
    try{
      const u = await wikiSearchThumb(item?.name, item?.place, item?.lat, item?.lng);
      if(u) return u;
    } catch(e) {}

    return null;
  };

  
  // Enrich missing fields from Wikidata / Wikipedia where possible (no scraping of commercial booking sites).
  // This keeps things client-side and compatible with a pure static build.
  const wdCache = new Map(); // qid -> {par, website, inception, wikiTitle, imageUrl, isLinksHint}

  const sparqlFetch = async (qids) => {
    if(!qids.length) return new Map();
    const values = qids.map(q => 'wd:' + q).join(' ');
    const query = `
SELECT ?qid ?image ?website ?par ?inception ?title WHERE {
  VALUES ?qid { ${values} }
  OPTIONAL { ?qid wdt:P18 ?image . }
  OPTIONAL { ?qid wdt:P856 ?website . }
  OPTIONAL { ?qid wdt:P3530 ?par . }
  OPTIONAL { ?qid wdt:P571 ?inception . }
  OPTIONAL {
    ?enwiki schema:about ?qid ;
           schema:isPartOf <https://en.wikipedia.org/> ;
           schema:name ?title .
  }
}`;
    const url = 'https://query.wikidata.org/sparql?format=json&query=' + encodeURIComponent(query);
    const res = await fetch(url, { headers: { 'Accept': 'application/sparql-results+json' } });
    if(!res.ok) throw new Error('Wikidata query failed');
    const js = await res.json();
    const out = new Map();
    (js?.results?.bindings || []).forEach(b => {
      const q = b?.qid?.value?.split('/').pop();
      if(!q) return;
      const cur = out.get(q) || {};
      if(b.image?.value) cur.image = b.image.value;
      if(b.website?.value) cur.website = b.website.value;
      if(b.par?.value) cur.par = Number(b.par.value) || cur.par;
      if(b.inception?.value) cur.inception = b.inception.value;
      if(b.title?.value) cur.wikiTitle = b.title.value;
      out.set(q, cur);
    });
    return out;
  };

  const inferLinksFromText = (txt) => {
    const s = (txt || '').toLowerCase();
    // Very light heuristic: only label as links if text strongly suggests it
    if(/\blinks\b/.test(s) && (/\bgolf\b/.test(s) || /\bcourse\b/.test(s))) return true;
    return false;
  };

  const enrichList = async (list) => {
    const qids = [...new Set((list||[])
      .map(x => (x?.tags?.wikidata || '').trim())
      .filter(q => /^Q\d+$/i.test(q) && !wdCache.has(q))
    )];

    // Batch query in chunks to be gentle to Wikidata Query Service
    const chunkSize = 40;
    for(let i=0;i<qids.length;i+=chunkSize){
      const chunk = qids.slice(i, i+chunkSize);
      try{
        const resMap = await sparqlFetch(chunk);
        chunk.forEach(q => wdCache.set(q, resMap.get(q) || {}));
      } catch(e){
        // If WDQS is rate limited, fail softly
        chunk.forEach(q => wdCache.set(q, {}));
      }
    }

    // Apply enrichment
    for(const item of (list||[])){
      const q = (item?.tags?.wikidata || '').trim();
      if(!q || !wdCache.has(q)) continue;
      const e = wdCache.get(q) || {};

      if(!item.par && e.par) item.par = e.par;

      // Wikipedia summary can provide a better image and also a links hint
      const needsImg = !imageCache.has(item.id);
      const hasWiki = !!e.wikiTitle && !item?.tags?.wikipedia;
      if(hasWiki){
        item.tags.wikipedia = 'en:' + e.wikiTitle;
      }

      if(needsImg && e.image){
        const file = decodeURIComponent(e.image.split('/').pop() || '');
        if(file){
          imageCache.set(item.id, 'https://commons.wikimedia.org/wiki/Special:FilePath/' + encodeURIComponent(file) + '?width=800');
        }
      }

      if(!item.style || item.style === 'unspecified'){
        // Avoid REST summary endpoints (can fail CORS from file://). Use API-based thumbnail only.
        if(item.tags.wikipedia){
          try{
            if(!imageCache.has(item.id)){
              const u = await wikipediaThumbFromTag(item.tags.wikipedia);
              if(u) imageCache.set(item.id, u);
            }
          } catch(err) {}
        }
      }
    }
  };

const hydrateImages = (list) => {
    (list||[]).forEach(async (item) => {
      const id = item.id;
      if(!id) return;

      if(imageCache.has(id)){
        const cached = imageCache.get(id);
        if(cached){
          const img = document.querySelector(`img[data-img="${CSS.escape(id)}"]`);
          const badge = document.querySelector(`[data-imgbadge="${CSS.escape(id)}"]`);
          if(img && img.src !== cached) img.src = cached;
          if(badge) badge.textContent = 'Image';
        }
        return;
      }

      imageCache.set(id, null);
      try{
        const url = await resolveImage(item);
        const img = document.querySelector(`img[data-img="${CSS.escape(id)}"]`);
        const badge = document.querySelector(`[data-imgbadge="${CSS.escape(id)}"]`);
        if(url){
          imageCache.set(id, url);
          if(img) img.src = url;
          if(badge) badge.textContent = 'Image';
        } else {
          if(badge) badge.textContent = 'No image';
        }
      } catch(e){
        const badge = document.querySelector(`[data-imgbadge="${CSS.escape(id)}"]`);
        if(badge) badge.textContent = 'No image';
      }
    });
  };

const cardHTML = (c, variant='list') => {
    const img = (typeof imageCache !== 'undefined' && imageCache.has(c.id) && imageCache.get(c.id)) ? imageCache.get(c.id) : PLACEHOLDER_IMG;

    const city = (c.city || c.place || '').trim() || '—';

    const holesDisplay = c.holes ? String(c.holes) : 'Unknown';
    const parDisplay = (c.par && String(c.par).trim() && String(c.par).trim().toLowerCase() !== 'unknown') ? String(c.par) : 'Unknown';

    const accessLabel = (a) => a==='public' ? 'Public' : a==='visitors' ? 'Visitors' : a==='members_only' ? 'Members only' : 'Unknown';
    const access = accessLabel(String(c.access || 'unknown'));

    const priceBand = String(c.price_band || 'unknown');
    const priceDisplay = (priceBand && priceBand !== 'unknown') ? titleCase(priceBand) : 'Unknown';

    const diffDisplay = (c.difficulty && c.difficulty.length) ? labels(c.difficulty).join(', ') : 'Unknown';
    const dressDisplay = (c.dress_code && c.dress_code.length)
      ? c.dress_code.map(x => x==='smart_casual' ? 'Smart casual' : titleCase(x)).join(', ')
      : 'Unknown';

    const vibeDisplay = (c.vibe && c.vibe.length) ? labels(c.vibe).join(', ') : 'Unknown';
    const ctDisplay = (c.course_type && c.course_type.length) ? labels(c.course_type).join(', ') : 'Unknown';

    const fac = (c.facilities && c.facilities.length)
      ? c.facilities.map(x => x==='practice_area' ? 'Practice areas' : titleCase(x)).join(', ')
      : 'Unknown';

    const extrasLabel = (x) => x==='alcohol_allowed' ? 'Alcohol allowed on course' :
      x==='smoking_allowed' ? 'Smoking allowed on course' : titleCase(x);
    const ex = (c.extras && c.extras.length) ? c.extras.map(extrasLabel).join(', ') : 'Unknown';

    const websiteHref = (c.website && /^https?:\/\//i.test(c.website)) ? c.website : '';
    const thirdAction = websiteHref
      ? `<a class="link" href="${escapeHtml(websiteHref)}" target="_blank" rel="noopener">Official Website</a>`
      : ``;

    const kindPill = c.kind==='range' ? ' <span class="pill">Driving range</span>' : '';

    return (variant === 'panel') ? `
      <div class="course-card panel-card">
        <div class="panel-body" style="position:relative">
          <button class="compare-toggle compact" type="button" data-compare="${escapeHtml(c.id)}" aria-pressed="false" aria-label="Compare">
            <div class="icon">★</div>
            <div class="label">Compare</div>
          </button>
          <img class="panel-thumb" data-img="${escapeHtml(c.id)}" src="${escapeHtml(img)}" alt="" onerror="this.onerror=null;this.src=window.PLACEHOLDER_IMG||this.src;" />
          <div class="panel-titlewrap">
            <div class="course-name">${escapeHtml(c.name || 'Golf')}${kindPill}</div>
            <div class="course-location">${escapeHtml(city)}</div>
          </div>

          <div class="meta-grid panel-meta">
            <div><div class="meta-label">Holes</div><div class="meta-value">${escapeHtml(holesDisplay)}</div></div>
            <div><div class="meta-label">Par</div><div class="meta-value">${escapeHtml(parDisplay)}</div></div>
            <div><div class="meta-label">Access</div><div class="meta-value">${escapeHtml(access)}</div></div>

            <div><div class="meta-label">Price band</div><div class="meta-value">${escapeHtml(priceDisplay)}</div></div>
            <div><div class="meta-label">Difficulty</div><div class="meta-value">${escapeHtml(diffDisplay)}</div></div>
            <div><div class="meta-label">Dress code</div><div class="meta-value">${escapeHtml(dressDisplay)}</div></div>

            <div><div class="meta-label">Vibe</div><div class="meta-value wrap">${escapeHtml(vibeDisplay)}</div></div>
            <div><div class="meta-label">Course type</div><div class="meta-value wrap">${escapeHtml(ctDisplay)}</div></div>
            <div><div class="meta-label">Extras</div><div class="meta-value wrap">${escapeHtml(ex)}</div></div>

            <div style="grid-column:span 3"><div class="meta-label">Facilities</div><div class="meta-value wrap">${escapeHtml(fac)}</div></div>
          </div>

          <div class="course-actions">
            <a class="link" data-details="${escapeHtml(c.id)}" href="course.html?id=${encodeURIComponent(c.id)}" target="_blank" rel="noopener">Full Details</a>
            <span class="link" data-maps="${escapeHtml(c.lat)},${escapeHtml(c.lng)}">Open in Maps</span>
            ${thirdAction}
          </div>
        </div>
      </div>
      ` : `
      <div class="course-card" data-card="${escapeHtml(c.id)}">
        <button class="compare-toggle" type="button" data-compare="${escapeHtml(c.id)}" aria-pressed="false" aria-label="Compare"><div class="icon">★</div><div class="label">Compare</div></button>
        <div style="position:relative">
          <div class="img-badge" data-imgbadge="${escapeHtml(c.id)}">Image</div>
          <img class="course-img" data-img="${escapeHtml(c.id)}" src="${escapeHtml(img)}" alt="" loading="lazy"
            onerror="this.onerror=null;this.src=window.PLACEHOLDER_IMG||this.src;" />
        </div>
        <div class="course-body">
          <div style="min-width:0">
            <div class="course-name">${escapeHtml(c.name || 'Golf')}${kindPill}</div>
            <div class="course-location">${escapeHtml(city)}</div>

            <div class="meta-grid">
              <div><div class="meta-label">Holes</div><div class="meta-value">${escapeHtml(holesDisplay)}</div></div>
              <div><div class="meta-label">Par</div><div class="meta-value">${escapeHtml(parDisplay)}</div></div>
              <div><div class="meta-label">Access</div><div class="meta-value">${escapeHtml(access)}</div></div>

              <div><div class="meta-label">Price band</div><div class="meta-value">${escapeHtml(priceDisplay)}</div></div>
              <div><div class="meta-label">Difficulty</div><div class="meta-value">${escapeHtml(diffDisplay)}</div></div>
              <div><div class="meta-label">Dress code</div><div class="meta-value">${escapeHtml(dressDisplay)}</div></div>

              <div><div class="meta-label">Vibe</div><div class="meta-value wrap">${escapeHtml(vibeDisplay)}</div></div>
              <div><div class="meta-label">Course type</div><div class="meta-value wrap">${escapeHtml(ctDisplay)}</div></div>
              <div><div class="meta-label">Extras</div><div class="meta-value wrap">${escapeHtml(ex)}</div></div>

              <div style="grid-column:span 3"><div class="meta-label">Facilities</div><div class="meta-value wrap">${escapeHtml(fac)}</div></div>
            </div>

            <div class="course-actions">
              <a class="link" data-details="${escapeHtml(c.id)}" href="course.html?id=${encodeURIComponent(c.id)}" target="_blank" rel="noopener">Full Details</a>
              <span class="link" data-maps="${escapeHtml(c.lat)},${escapeHtml(c.lng)}">Open in Maps</span>
              ${thirdAction}
            </div>
          </div>
        </div>
      </div>
      `;
  };

  const render = (list) => {
    $('courseCount').textContent = String(list.length);
    const box = $('resultsList');

    if(!list.length){
      box.innerHTML = `<div style="padding:14px;border:1px solid rgba(255,255,255,.12);border-radius:14px;background:rgba(255,255,255,.04);opacity:.9">No results yet. Select an area on the map.</div>`;
      return;
    }

    box.innerHTML = list.map(cardHTML).join('');
    hydrateImages(list);
    updateCompareUi();


    box.querySelectorAll('[data-save]').forEach(el => el.addEventListener('click', (e) => {
      const id = e.currentTarget.getAttribute('data-save');
      if(!id) return;
      if(saved.has(id)) saved.delete(id); else saved.add(id);
      saveSaved();
      refresh();
    }));

    box.querySelectorAll('[data-maps]').forEach(el => el.addEventListener('click', (e) => {
      const q = e.currentTarget.getAttribute('data-maps');
      if(!q) return;
      window.open('https://www.google.com/maps?q=' + encodeURIComponent(q), '_blank');
    }));

    box.querySelectorAll('[data-details]').forEach(el => el.addEventListener('click', (e) => {
      const id = e.currentTarget.getAttribute('data-details');
      if(!id) return;
      const item = (list||[]).find(x => x.id === id);
      try{ sessionStorage.setItem('gdb_detail_item', JSON.stringify(item || {id})); } catch(err) {}
      e.preventDefault();
      e.stopPropagation();
      if(typeof window.openCourseDetailsInNewTab === 'function'){
        window.openCourseDetailsInNewTab(id);
      } else {
        window.open('./gdb_course_detail.html?id=' + encodeURIComponent(id), '_blank', 'noopener');
      }
    }));
  };


  const wireCardActions = (root, list) => {
    if(!root) return;

    root.querySelectorAll('[data-save]').forEach(el => el.addEventListener('click', (e) => {
      const id = e.currentTarget.getAttribute('data-save');
      if(!id) return;
      if(saved.has(id)) saved.delete(id); else saved.add(id);
      saveSaved();
      refresh();
      // keep quick view in sync
      const item = (list||[]).find(x => x.id === id);
      if(item) openSidePanel(item, list, {preserveScroll:true});
    }));

    root.querySelectorAll('[data-maps]').forEach(el => el.addEventListener('click', (e) => {
      const q = e.currentTarget.getAttribute('data-maps');
      if(!q) return;
      window.open('https://www.google.com/maps?q=' + encodeURIComponent(q), '_blank');
    }));

    root.querySelectorAll('[data-details]').forEach(el => el.addEventListener('click', (e) => {
      // Always open Full Details in a NEW tab (keep search results visible)
      e.preventDefault();
      e.stopPropagation();
      const id = e.currentTarget.getAttribute('data-details');
      if(!id) return;
      const item = (list||[]).find(x => x.id === id);
      try{ sessionStorage.setItem('gdb_detail_item', JSON.stringify(item || {id})); } catch(err) {}
      if(typeof window.openCourseDetailsInNewTab === 'function'){
        window.openCourseDetailsInNewTab(id);
      } else {
        window.open('./gdb_course_detail.html?id=' + encodeURIComponent(id), '_blank', 'noopener');
      }
    }));
  };

  const closeSidePanel = () => {
    const p = $('mapSidePanel');
    const b = $('mapSidePanelBody');
    if(b) b.innerHTML = '';
    if(p) p.style.display = 'none';
  };

  const openSidePanel = (course, list, opts={}) => {
    const p = $('mapSidePanel');
    const b = $('mapSidePanelBody');
    if(!p || !b || !course) return;

    const prevScroll = b.scrollTop || 0;
    b.innerHTML = cardHTML(course, 'panel');

    // Keep compare buttons in sync
    updateCompareUi();

    // Reset scroll to top when selecting a new course (unless explicitly preserving)
    if(!opts.preserveScroll) b.scrollTop = 0;

    // hydrate image for just this card
    hydrateImages([course]);

    wireCardActions(b, list);

    p.style.display = 'flex';
    if(opts.preserveScroll) b.scrollTop = prevScroll;
  };


    const renderMarkers = (list) => {
    if(!markers) return;
    markers.clearLayers();

    const inList = new Set((list || []).map(x => x && x.id).filter(Boolean));
    const extras = [];
    if(compareSet && compareSet.size && GDB_BY_ID){
      compareSet.forEach(id => {
        if(!inList.has(id) && GDB_BY_ID.has(id)){
          extras.push(GDB_BY_ID.get(id));
        }
      });
    }

    // Marker list includes current results plus any compare selections, even if outside the current search area
    const markerList = [...(list || []), ...extras];

    markerList.forEach(c => {
      const m = L.marker([c.lat,c.lng],{
        title:c.name||'Golf',
        icon:markerIcon(c.kind, compareSet && compareSet.has(c.id))
      }).addTo(markers);

      // Hover label
      m.bindTooltip(`${kindEmoji(c.kind)} ${c.name||'Golf'}`, {direction:'top',opacity:0.95,sticky:true});

      // Click: open quick view panel on the right
      m.on('click', () => openSidePanel(c, markerList));
    });
  };
  const refresh = () => {
    if(mode !== 'map' && mode !== 'text' && mode !== 'near') return;

    const shown = liveItems
      .filter(x => visibleKinds.has(x.kind || 'course'))
      .filter(pointIn)
      .filter(passes);

    const list = sortList(shown);
    lastRenderedList = list;
    
    currentResults = list;
    window.currentResults = currentResults;
render(list);
    renderMarkers(list);

    // Filters bar only appears once data is loaded for an area or Text Search
    const hasLoadedResults = (liveStatus === 'loaded') && Array.isArray(liveItems) && liveItems.length > 0;
    const fw = $('filtersWrap');
    if(fw) fw.style.display = hasLoadedResults ? 'block' : 'none';
    const hint = $('selectAreaHint');
    if(hint) hint.style.display = hasLoadedResults ? 'none' : 'block';

    setLivePill(
      liveStatus === 'loading' ? 'Loading data' :
      liveStatus === 'error' ? 'Data Loaded · error' :
      liveStatus === 'idle' ? idlePillText() :
      `Data Loaded · ${list.length} shown · ${liveItems.length} total`
    );

    if(isFileOrigin){
      const note = $('liveNote');
      if(note) note.style.display = 'block';
    }
  };

  const geojsonToOverpassPoly = (g) => {
    if(!g) return '';
    try{
      // Pick the largest exterior ring so MultiPolygons like countries work reliably.
      let ring = null;

      if(g.type === 'Polygon' && Array.isArray(g.coordinates?.[0])){
        ring = g.coordinates[0];
      } else if(g.type === 'MultiPolygon' && Array.isArray(g.coordinates)){
        let best = null;
        let bestArea = -1;
        for(const poly of g.coordinates){
          const r = poly?.[0];
          if(!Array.isArray(r) || r.length < 4) continue;
          // Use turf area as a robust heuristic for "largest part"
          const feat = turf.polygon([r]);
          const a = Math.abs(turf.area(feat));
          if(a > bestArea){ bestArea = a; best = r; }
        }
        ring = best;
      }

      if(!ring || ring.length < 3) return '';

      // Keep Overpass poly strings manageable (Overpass can choke on very dense borders).
      // Target <= 1800 points for safety.
      const MAX_POINTS = 1800;
      if(ring.length > MAX_POINTS){
        const step = Math.ceil(ring.length / MAX_POINTS);
        const slim = [];
        for(let i=0;i<ring.length;i+=step) slim.push(ring[i]);
        // Ensure closed ring
        const first = slim[0], last = slim[slim.length-1];
        if(first && last && (first[0] !== last[0] || first[1] !== last[1])) slim.push(first);
        ring = slim;
      }

      return ring.map(([lon,lat]) => `${lat} ${lon}`).join(' ');
    } catch(e){
      return '';
    }
  };

  const buildLiveItems = (elements) => {
    const out = [];
    const seen = new Set();

const isPlayableCourse = (t, holes, nameLower) => {
  // hard exclusions
  const golfType = String(t.golf || '').toLowerCase();
  const leisure = String(t.leisure || '').toLowerCase();
  const amenity = String(t.amenity || '').toLowerCase();
  const building = String(t.building || '').toLowerCase();
  const landuse = String(t.landuse || '').toLowerCase();
  const sport = String(t.sport || '').toLowerCase();

  // non playable or different sports
  if(['miniature_golf','mini_golf','pitch_and_putt','adventure_golf','disc_golf','footgolf'].includes(golfType)) return false;
  if(leisure === 'miniature_golf') return false;
  if(['school','college','university','kindergarten'].includes(amenity)) return false;
  if(['school','college','university'].includes(building)) return false;
  if(landuse === 'education') return false;

  // name based exclusions
  if(nameLower && nameLower.includes('school') && !nameLower.includes('golf')) return false;
  if(nameLower && nameLower.includes('academy') && !nameLower.includes('golf')) return false;
  if(nameLower && (nameLower.includes('pitch and putt') || nameLower.includes('mini golf') || nameLower.includes('minigolf') || nameLower.includes('adventure golf'))) return false;

  // common name based exclusions (only when there are no strong course signals)
  const hasStrongSignals =
    (holes && holes >= 6) ||
    String(t['golf:holes']||'').trim() ||
    String(t.holes||'').trim() ||
    String(t['golf:par']||'').trim() ||
    String(t.par||'').trim() ||
    String(t['golf:green_fee']||'').trim() ||
    String(t.green_fee||'').trim() ||
    String(t.website||t['contact:website']||'').trim() ||
    (String(t.operator||'').toLowerCase().includes('golf')) ||
    (String(t.brand||'').toLowerCase().includes('golf'));

  if(!hasStrongSignals){
    if(nameLower.includes('school')) return false;
    if(nameLower.includes('academy') && !nameLower.includes('golf')) return false;
    if(nameLower.includes('sports centre') || nameLower.includes('sports center')) return false;
    if(nameLower.includes('pro shop')) return false;
  }

  // sports mismatch
  if(sport && sport !== 'golf' && sport !== 'multi') return false;

  return true;
};

    const first = (...vals) => {
      for(const v of vals){
        const s = String(v||'').trim();
        if(s) return s;
      }
      return '';
    };

    const parseIntSafe = (v) => {
      const n = parseInt(String(v||'').replace(/[^\d]/g,''), 10);
      return Number.isFinite(n) ? n : null;
    };

    const parseHoles = (t) => {
      // Common tagging: golf:holes, holes, golf_course:holes
      const direct = parseIntSafe(first(t['golf:holes'], t.holes, t['golf_course:holes'], t['course:holes']));
      if(direct) return direct;

      // Also commonly tagged as golf:course=18_hole / 9_hole etc
      const gc = String(first(t['golf:course'], t['golf_course'], t['course'], t['golf:course:type'])).trim().toLowerCase();
      const m = gc.match(/(\d{1,2})\s*[_-]?\s*hole/);
      if(m){
        const n = parseInt(m[1], 10);
        if(Number.isFinite(n) && n > 0 && n <= 54) return n;
      }
      return null;
    };

    const parsePar = (t) => {
      return parseIntSafe(first(t['golf:par'], t.par, t['course:par']));
    };

    const parseLengthMeters = (t) => {
      const raw = first(t['golf:length'], t.length, t['course:length']);
      if(!raw) return null;
      const s = String(raw).trim().toLowerCase();
      const num = parseFloat(s.replace(/[^0-9.]/g,''));
      if(!Number.isFinite(num)) return null;

      // try explicit unit tags
      const unit = String(first(t['golf:length:unit'], t['length:unit'])).trim().toLowerCase();

      // simple inference by suffix
      if(unit === 'm' || /m(et(re|er)s?)?$/.test(s)) return Math.round(num);
      if(unit === 'km' || /km$/.test(s)) return Math.round(num * 1000);
      if(unit === 'yd' || unit === 'yards' || /yds?$/.test(s) || /yards?$/.test(s)) return Math.round(num * 0.9144);
      if(unit === 'ft' || /fts?$/.test(s) || /feet$/.test(s)) return Math.round(num * 0.3048);

      // fallback: if value is very large, assume meters, otherwise assume yards
      if(num > 4000) return Math.round(num);
      return Math.round(num * 0.9144);
    };

    const normalizeAccess = (t) => {
      // access is often: yes, permissive, private, members, customers
      const access = String(first(t.access, t['golf:access'], t['access:conditional'])).toLowerCase();
      const fee = String(first(t.fee, t['golf:fee'], t['fee:conditional'])).toLowerCase();
      const membership = String(first(t.membership, t['club:membership'])).toLowerCase();

      // public signals
      if(access === 'yes' || access === 'permissive' || access === 'public' || access === 'customers') return 'public';
      if(fee === 'yes' || fee === 'customers') return 'public';

      // members signals
      if(access === 'private' || access === 'no') return 'members';
      if(access.includes('member')) return 'members';
      if(membership && membership !== 'no') return 'members';

      // unknown
      return null;
    };

    const parseGreenFee = (t) => {
      // attempts to parse amounts from common tags. This will be imperfect, but better than empty.
      const raw = first(t['golf:green_fee'], t.green_fee, t.charge, t['charge:conditional'], t.fee);
      if(!raw) return { low:null, high:null };

      const s = String(raw).replace(/,/g,' ').trim();
      // extract numbers like 50, 50.00, 50-90, 50 to 90
      const nums = (s.match(/(\d+(?:\.\d+)?)/g) || []).map(x => Math.round(parseFloat(x))).filter(n => Number.isFinite(n) && n>0);
      if(!nums.length) return { low:null, high:null };

      const low = Math.min(...nums);
      const high = Math.max(...nums);
      return { low, high };
    };

    const hasYes = (v) => {
      const s = String(v||'').toLowerCase().trim();
      return s === 'yes' || s === 'true' || s === '1';
    };

    const addFacility = (arr, key, label) => {
      if(arr.includes(key)) return;
      arr.push(key);
    };

    for(const el of elements){
      const t = el.tags || {};
      const lat = (el.type === 'node') ? el.lat : (el.center ? el.center.lat : null);
      const lng = (el.type === 'node') ? el.lon : (el.center ? el.center.lon : null);
      if(lat == null || lng == null) continue;

      // classify
let kind = null;
if(t.golf === 'driving_range' || t.leisure === 'driving_range') kind = 'range';
else if(t.leisure === 'golf_course' || t.golf === 'course') kind = 'course';
else continue;

      // fix common mis-tags: if something looks like a range, treat it as a range
      const holes = parseHoles(t);
      const nameRaw = first(t.name, t['name:en'], t['official_name'], t['short_name'], t['alt_name'], t.operator, t.brand);
      const nameLower = String(nameRaw||'').toLowerCase();
      if(kind === 'course'){
        if(t.golf === 'driving_range' || nameLower.includes('driving range')) kind = 'range';
      }
      if(kind === 'range'){
        if(holes && holes >= 6) kind = 'course';
      }

      if(kind === 'course'){
        const nl = String(nameRaw||'').toLowerCase();
        if(!isPlayableCourse(t, holes, nl)) continue;
      }

// name cleanup: prefer dropping truly unnamed items rather than polluting results
let name = nameRaw;

// remove generic or junk names that appear in OSM
const nameLower2 = String(name||'').trim().toLowerCase();
const junkNames = new Set([
  'golf course','golfclub','golf club','golfcourse','golf','course','club',
  'unnamed','unamed course','unamed golf course','unknown','no name','noname'
]);

if(!name || junkNames.has(nameLower2) || nameLower2.includes('unnamed')){
  const op = first(t.operator, t.brand);
  if(op) name = `${op} ${kind === 'course' ? 'Golf Course' : 'Driving Range'}`;
}

if(!name) continue;
// --- Quality gate: keep playable, public facing golf only (best effort) ---
const norm = (s) => String(s||'').toLowerCase().replace(/[^a-z0-9 ]+/g,' ').replace(/\s+/g,' ').trim();
const nm = norm(name);
const badAmenity = new Set(['school','college','university','kindergarten']);
if(badAmenity.has(String(t.amenity||'').toLowerCase())) continue;
if(String(t.landuse||'').toLowerCase() === 'education') continue;

const badGolf = new Set(['pitch_and_putt','miniature_golf','minigolf','adventure_golf','disc_golf','footgolf']);
const golfVal = String(t.golf||'').toLowerCase();
if(badGolf.has(golfVal)) continue;

// Name based exclusions only when we have weak evidence it is a real course
const hasGolfWords = /\b(golf|links|country club|golfclub|golf club|golf course|gc)\b/.test(nm);
const hasBookingSignal = !!(t.website || t['contact:website'] || t.phone || t['contact:phone']);
const holesHint = holes || parseInt(String(t['golf:holes']||''),10) || 0;

const looksNonPlayable =
  /\b(mini\s*golf|adventure\s*golf|pitch\s*(and|&)\s*putt|putting\s*green|footgolf|disc\s*golf)\b/.test(nm) ||
  /\b(school|college|university|academy)\b/.test(nm) ||
  /\b(sports\s*centre|sports\s*center|sports\s*club|leisure\s*centre|leisure\s*center)\b/.test(nm);

if(kind === 'course'){
  // If it looks non playable and we do not have strong course signals, drop it
  const strongCourseSignal = (holesHint >= 6) || hasBookingSignal || hasGolfWords || (String(t.leisure||'') === 'golf_course');
  if(looksNonPlayable && !strongCourseSignal) continue;

  // If we have *no* course signal at all, drop it (cuts out mis tagged POIs)
  if(!strongCourseSignal) continue;
}

// place
      const placeParts = [t['addr:city'], t['addr:suburb'], t['addr:state'], t['addr:country']].filter(Boolean);
      const place = placeParts.length ? placeParts.join(', ') : (t['is_in:city'] || t['is_in'] || '');

      const id = `osm-${el.type}-${el.id}`;

      // facilities mapped to existing filter keys
      const facilities = [];
      if(hasYes(t.clubhouse) || (t.amenity === 'clubhouse')) addFacility(facilities,'clubhouse');
      if(t.amenity === 'restaurant' || t['golf:restaurant'] || hasYes(t.restaurant)) addFacility(facilities,'restaurant');
      if(t.shop === 'golf' || t['golf:pro_shop'] || t['golf:shop'] || hasYes(t.pro_shop)) addFacility(facilities,'proShop');
      if(kind === 'course' && (t.golf === 'driving_range' || hasYes(t['golf:driving_range']) || hasYes(t.driving_range))) addFacility(facilities,'range');
      if(hasYes(t['golf:club_hire']) || hasYes(t.club_hire) || hasYes(t.rental)) addFacility(facilities,'clubHire');
      if(hasYes(t['golf:caddie']) || hasYes(t.caddie)) addFacility(facilities,'caddie');
      if(t.amenity === 'toilets' || hasYes(t.toilets) || hasYes(t['toilets:wheelchair'])) addFacility(facilities,'toilets');
      if(hasYes(t.shower) || hasYes(t.showers) || hasYes(t['golf:showers'])) addFacility(facilities,'showers');
      if(hasYes(t['golf:lessons']) || hasYes(t.lessons) || hasYes(t['golf:academy'])) addFacility(facilities,'lessons');

      // walkability
      const walkability = [];
      const cart = String(first(t['golf:cart'], t['golf:buggy'], t.cart, t.buggy)).toLowerCase();
      if(cart === 'no' || cart === 'not_allowed') walkability.push('walkable');
      if(cart === 'yes' || cart === 'recommended') walkability.push('cartRecommended');

      // access and price
      const access = normalizeAccess(t);
      const fees = parseGreenFee(t);

      const par = parsePar(t);
      const lengthM = parseLengthMeters(t);

// practice and course style signals (best-effort from OSM tags)
const hasPractice = kind === 'range' ||
  hasYes(t['golf:driving_range']) || hasYes(t.driving_range) ||
  hasYes(t['golf:practice']) || hasYes(t.practice) ||
  hasYes(t['golf:academy']) || hasYes(t.academy) || hasYes(t['golf:lessons']);

const style = String(first(t['golf:style'], t['course:style'], t['golf:course_style'], t['golf:type'], t.surface)).trim().toLowerCase() || null;

      const key = `${kind}|${name.toLowerCase()}|${lat.toFixed(5)}|${lng.toFixed(5)}`;
      if(seen.has(key)) continue;
      seen.add(key);

      out.push({
        id,
        osm: { type: el.type, id: el.id },
        kind,
        name,
        lat, lng,
        holes,
        par,
        lengthM,
        priceLow: fees.low,
        priceHigh: fees.high,
        access,
        style,
        hasPractice,
        accommodation: null,
        difficulty: [],
        walkability,
        vibe: [],
        facilities,
        tags: t,
        place
      });
    }
    
    // --- Dedupe: collapse node/way/relation duplicates for the same place ---
    const havKm = (aLat,aLng,bLat,bLng) => {
      const toRad = (d) => d * Math.PI / 180;
      const R = 6371;
      const dLat = toRad(bLat - aLat);
      const dLng = toRad(bLng - aLng);
      const s1 = Math.sin(dLat/2), s2 = Math.sin(dLng/2);
      const aa = s1*s1 + Math.cos(toRad(aLat))*Math.cos(toRad(bLat))*s2*s2;
      return 2 * R * Math.asin(Math.min(1, Math.sqrt(aa)));
    };

    const nameKey = (s) => String(s||'')
      .toLowerCase()
      .replace(/[^a-z0-9 ]+/g,' ')
      .replace(/\b(the|golf|club|course|links)\b/g,' ')
      .replace(/\s+/g,' ')
      .trim();

    const pref = (x) => {
      const t = x?.tags || {};
      const base = (x?.osm?.type === 'relation') ? 30 : (x?.osm?.type === 'way') ? 20 : 10;
      const holesB = x?.holes ? 3 : 0;
      const parB = x?.par ? 1 : 0;
      const webB = (t.website || t['contact:website']) ? 2 : 0;
      const phoneB = (t.phone || t['contact:phone']) ? 1 : 0;
      return base + holesB + parB + webB + phoneB;
    };

    const groups = new Map();
    for(const it of out){
      const k = nameKey(it.name);
      const arr = groups.get(k) || [];
      arr.push(it);
      groups.set(k, arr);
    }

    const finalOut = [];
    for(const arr of groups.values()){
      arr.sort((a,b) => pref(b) - pref(a));
      const kept = [];
      for(const it of arr){
        const near = kept.some(k => havKm(k.lat,k.lng,it.lat,it.lng) < 0.75); // 250m
        if(!near){
          kept.push(it);
        } else {
          // If this one is materially better, replace the nearest
          let bestIdx = -1;
          let bestDist = 999;
          for(let i=0;i<kept.length;i++){
            const d = havKm(kept[i].lat, kept[i].lng, it.lat, it.lng);
            if(d < bestDist){ bestDist = d; bestIdx = i; }
          }
          if(bestIdx >= 0 && pref(it) > pref(kept[bestIdx]) + 2){
            kept[bestIdx] = it;
          }
        }
      }
      finalOut.push(...kept);
    }

    return finalOut;

  };

  const OVERPASS_ENDPOINTS = [
    'https://overpass-api.de/api/interpreter',
    'https://overpass.kumi.systems/api/interpreter',
    'https://overpass.openstreetmap.ru/api/interpreter'
  ];

  // Primary Overpass endpoint for boundary resolution helpers (Wikidata/ISO lookups)
  const OVERPASS_URL = OVERPASS_ENDPOINTS[0];


  const fetchLive = async () => {
    if(mode !== 'map' && mode !== 'text' && mode !== 'near') return;

    // Only fetch once the user has selected an area
    if(!geom){
      liveStatus = 'idle';
      liveItems = [];
      refresh();
      activeTextAliasCfg = null;
      return;
    }

    liveStatus = 'loading';
    refresh();

    const ok = await loadGdbLocal();
    if(!ok){
      liveStatus = 'error';
      liveItems = [];
      refresh();
      return;
    }

    // Build local live list, then let refresh() handle filters + sort
        const all = GDB_COURSES.map(normalizeCourse);
        GDB_ALL = all;
        GDB_BY_ID = new Map(all.map(x => [x.id, x]));

// Cache dataset for Full Details page (local use)
try{
  if(Array.isArray(GDB_COURSES) && GDB_COURSES.length){
    localStorage.setItem('GDB_COURSES_CACHE_V1', JSON.stringify(GDB_COURSES));
    localStorage.setItem('GDB_COURSES_CACHE_TS', String(Date.now()));
  }
}catch(e){}

    // Geo filter: keep only those within geom
    liveItems = all.filter(pointIn);

    liveStatus = 'loaded';
    refresh();
  };

    const resetView = () => {
    if(!map) return;
    try{ map.closePopup(); } catch(e){}
    map.setView(HOME_VIEW.center, HOME_VIEW.zoom, {animate:true});
  };

const clearArea = () => {
    if(drawn) drawn.clearLayers();
    geom = null;
    if(map && clickCircle){ map.removeLayer(clickCircle); clickCircle = null; }

    // Clear any Text Search marker or area overlay
    if(map && textSearchMarker){ map.removeLayer(textSearchMarker); textSearchMarker = null; }
    if(map && textAreaLayer){ map.removeLayer(textAreaLayer); textAreaLayer = null; }
    selectedTextHit = null;
    if(map && textSearchMarker){ map.removeLayer(textSearchMarker); textSearchMarker = null; }

    // Close the map quick view panel
    const sp = $('mapSidePanel');
    const spb = $('mapSidePanelBody');
    if(sp) sp.style.display = 'none';
    if(spb) spb.innerHTML = '';

    liveAbort && liveAbort.abort();
    liveStatus = 'idle';
    liveItems = [];
    imageCache.clear();

    if(markers) markers.clearLayers();

    setLivePill(idlePillText());

    // In map mode, keep the live pill hidden until a draw tool is selected.
    const pill = $('livePill');
    if(pill) pill.style.display = (mode === 'map' && !mapToolArmed) ? 'none' : '';

    const g = $('drawGuide');
    if(g){
      g.textContent = (mode === 'text')
        ? 'Type a location to load golf data'
        : (mode === 'near')
          ? 'Finding courses near you'
          : 'Select a drawing tool, then mark an area to load golf data';
    }

    refresh();
  };

  const initMap = () => {
    if(map) return;
    if(!ensureLeaflet()) return;

    map = L.map('map').setView(HOME_VIEW.center, HOME_VIEW.zoom);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom:18, attribution:'&copy; OpenStreetMap contributors'}).addTo(map);

    markers = L.layerGroup().addTo(map);

    drawn = new L.FeatureGroup();
    map.addLayer(drawn);

    drawControl = new L.Control.Draw({
      edit:{featureGroup:drawn},
      // polygon is the manual trace tool. circle is useful for quick "how far" searches.
      draw:{polygon:true,rectangle:true,circle:true,marker:false,polyline:false,circlemarker:false}
    });
    map.addControl(drawControl);

    map.on('draw:drawstart', () => {
      mapToolArmed = true;
      const pill = $('livePill');
      if(pill) pill.style.display = '';
      setLivePill(idlePillText());
      const g = $('drawGuide');
      if(g) g.textContent = 'Mark your area';
    });

    map.on(L.Draw.Event.CREATED, (e) => {
      const g = $('drawGuide');
      if(g) g.textContent = 'Area selected';
      drawn.clearLayers();
      drawn.addLayer(e.layer);
      if(clickCircle){ map.removeLayer(clickCircle); clickCircle = null; }

      // Leaflet circle toGeoJSON returns a Point, not a polygon.
      // Convert circle to a polygon for Overpass poly queries.
      if(e.layerType === 'circle' && e.layer && typeof e.layer.getRadius === 'function'){
        const ll = e.layer.getLatLng();
        const rKm = (Number(e.layer.getRadius()) || 0) / 1000;
        const poly = turf.circle([ll.lng, ll.lat], Math.max(rKm, 0.05), {steps:64, units:'kilometers'});
        geom = poly.geometry;
      } else {
        geom = e.layer.toGeoJSON().geometry;
      }
      fetchLive();
      refresh();
    });

    map.on(L.Draw.Event.EDITED, () => {
      let geo = null;
      let circle = null;
      drawn.eachLayer(l => {
        if(l && typeof l.getRadius === 'function' && typeof l.getLatLng === 'function') circle = l;
        else geo = l.toGeoJSON();
      });

      if(circle){
        const ll = circle.getLatLng();
        const rKm = (Number(circle.getRadius()) || 0) / 1000;
        const poly = turf.circle([ll.lng, ll.lat], Math.max(rKm, 0.05), {steps:64, units:'kilometers'});
        geom = poly.geometry;
      } else {
        geom = geo ? geo.geometry : null;
      }
      fetchLive();
      refresh();
    });

    // Start idle until an area is selected
    liveStatus = 'idle';
    liveItems = [];
    refresh();
  };


// Text Search (Nominatim). Uses the same map and sidebar. It replaces any previous map-drawn area.
let textSearchMarker = null;
let textAreaLayer = null;
let lastTextHits = [];
let selectedTextHit = null;
let activeTextAliasCfg = null;
let acAbort = null;
let acTimer = null;
let radiusOverride = false;


// User proximity bias for autocomplete ranking
// Lightweight client hints only. No persistence.
const userBias = {
  lat: null,
  lng: null,
  countryCode: null,
  ready: false
};

const guessCountryFromTimezone = () => {
  try{
    const tz = String(Intl.DateTimeFormat().resolvedOptions().timeZone || '').toLowerCase();
    if(tz.includes('europe/london') || tz.includes('london')) return 'gb';
  } catch(e){}
  return null;
};

const haversineKm = (lat1, lon1, lat2, lon2) => {
  const toRad = (d) => (d * Math.PI) / 180;
  const R = 6371;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat/2)**2 +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
};

const initUserBias = async () => {
  if(userBias.ready) return;
  userBias.countryCode = guessCountryFromTimezone();

  // Try geolocation to bias autocomplete and reduce wrong-continent results.
  // If denied or unavailable, we still keep the timezone guess.
  try{
    if(!navigator.geolocation){ if(!Number.isFinite(userBias.lat) || !Number.isFinite(userBias.lng)){
    // Default bias: UK (helps common searches like counties) while still allowing worldwide results
    userBias.lat = 51.5074;
    userBias.lng = -0.1278;
  }
  if(!userBias.countryCode){
    userBias.countryCode = 'gb';
  }
  userBias.ready = true; return; }
    const pos = await new Promise((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(resolve, reject, {enableHighAccuracy:false, timeout:3500, maximumAge:600000});
    });
    const lat = Number(pos?.coords?.latitude);
    const lng = Number(pos?.coords?.longitude);
    if(Number.isFinite(lat) && Number.isFinite(lng)){
      userBias.lat = lat; userBias.lng = lng;
      // Reverse geocode once to get a reliable country code
      try{
        const url = 'https://nominatim.openstreetmap.org/reverse?format=jsonv2&addressdetails=1&accept-language=en&lat=' + encodeURIComponent(String(lat)) + '&lon=' + encodeURIComponent(String(lng));
        const res = await fetch(url, {headers:{'Accept':'application/json'}});
        if(res.ok){
          const data = await res.json();
          const cc = String(data?.address?.country_code || '').trim().toLowerCase();
          if(cc) userBias.countryCode = cc;
        }
      } catch(e){}
    }
  } catch(e){}

  // Hard fallback so we still get sensible ranking and viewbox bias
  if(!Number.isFinite(userBias.lat) || !Number.isFinite(userBias.lng)){
    userBias.lat = 51.5074;  // London
    userBias.lng = -0.1278;
  }
  if(!userBias.countryCode){
    userBias.countryCode = 'gb';
  }

  userBias.ready = true;
};



// Nominatim supports a soft viewbox bias. We use it to prioritise nearby results (eg UK for UK users)
// without blocking worldwide search.
// Returns a string "left,top,right,bottom" or empty string.
const getNominatimViewboxParam = () => {
  const lat = Number(userBias.lat), lng = Number(userBias.lng);
  if(!Number.isFinite(lat) || !Number.isFinite(lng)) return '';
  // Rough bias box: ~6 degrees wide, ~4 degrees tall
  const left = lng - 3.0;
  const right = lng + 3.0;
  const top = lat + 2.0;
  const bottom = lat - 2.0;
  return `${left},${top},${right},${bottom}`;
};

// Region alias layer
// Goal: handle golf travel regions that users search for which may not resolve cleanly as admin polygons.
// We try Nominatim with country hints and boundary preference, then fall back to a sensible circle.
const REGION_ALIASES = [
  // Golf vernacular regions and islands that are commonly searched but are not always strict admin units.
  // Goal: treat these like countries whenever possible (real polygon), never like a single pin.
  // Resolution order: explicit Wikidata QIDs -> OSM relation boundary via Overpass, then Nominatim polygon, then sensible fallback circle.
  { key:'algarve',        label:'Algarve, Portugal',        query:'Algarve',        countrycodes:'pt', qids:['Q26831'],                     fallback:{ lat:37.10, lng:-8.25, radiusMiles:70 } },
  { key:'costa del sol',  label:'Costa del Sol, Spain',     query:'Costa del Sol',  countrycodes:'es', qids:['Q215254','Q2997038','Q2452346'], fallback:{ lat:36.52, lng:-4.90, radiusMiles:80 } },
  { key:'costa blanca',   label:'Costa Blanca, Spain',      query:'Costa Blanca',   countrycodes:'es', qids:['Q764324'],                     fallback:{ lat:38.36, lng:-0.49, radiusMiles:85 } },
  { key:'costa brava',    label:'Costa Brava, Spain',       query:'Costa Brava',    countrycodes:'es', qids:['Q216884'],                      fallback:{ lat:41.95, lng:3.20, radiusMiles:80 } },
  { key:'mallorca',       label:'Mallorca, Spain',          query:'Mallorca',       countrycodes:'es', qids:['Q5765'],                       fallback:{ lat:39.62, lng:2.90, radiusMiles:55 } },
  { key:'majorca',        label:'Majorca, Spain',           query:'Mallorca',       countrycodes:'es', qids:['Q5765'],                       fallback:{ lat:39.62, lng:2.90, radiusMiles:55 } },
  { key:'madeira',        label:'Madeira, Portugal',        query:'Madeira',        countrycodes:'pt', qids:['Q26262'],                      fallback:{ lat:32.76, lng:-16.96, radiusMiles:55 } },
  { key:'canary islands', label:'Canary Islands, Spain',    query:'Canary Islands', countrycodes:'es', qids:['Q5813'],                       fallback:{ lat:28.30, lng:-15.50, radiusMiles:260 } },
  { key:'tenerife',       label:'Tenerife, Spain',          query:'Tenerife',       countrycodes:'es', qids:['Q23102'],                      fallback:{ lat:28.29, lng:-16.62, radiusMiles:75 } },
  { key:'gran canaria',   label:'Gran Canaria, Spain',      query:'Gran Canaria',   countrycodes:'es', qids:['Q60825'],                      fallback:{ lat:27.96, lng:-15.58, radiusMiles:70 } },
];

const normKey = (s) => String(s||'').toLowerCase().replace(/\s+/g,' ').trim();

// Autocomplete must prefer golf travel regions over generic place matches.
// We treat region aliases as curated intent signals and lift them to the top of suggestions.
const scoreAliasMatch = (aliasKey, q) => {
  const key = normKey(aliasKey);
  const qq = normKey(q);
  if(!key || !qq) return 999;

  if(qq === key) return 0;                 // exact
  if(key.startsWith(qq)) return 1;         // user typing the start of the alias
  if(qq.startsWith(key)) return 2;         // user typed the alias plus extras
  if(key.includes(qq)) return 3;           // partial anywhere

  // Token overlap fallback (eg user types "costa sol" or "canary")
  const qParts = qq.split(' ').filter(Boolean);
  if(qParts.length >= 2){
    const all = qParts.every(p => key.includes(p));
    if(all) return 4;
  } else if(qParts.length === 1){
    const p = qParts[0];
    if(p.length >= 4 && key.split(' ').some(w => w.startsWith(p))) return 5;
  }
  return 999;
};

const findAliasSuggestions = (q, limit=6) => {
  const qq = normKey(q);
  if(!qq || qq.length < 2) return [];
  const scored = [];
  for(const a of REGION_ALIASES){
    const s = scoreAliasMatch(a.key, qq);
    if(s >= 999) continue;
    scored.push({ a, s });
  }
  scored.sort((x,y) => (x.s - y.s) || (normKey(y.a.key).length - normKey(x.a.key).length) || String(x.a.label).localeCompare(String(y.a.label)));
  const out = [];
  const seen = new Set();
  for(const x of scored){
    const k = normKey(x.a.key) + '|' + normKey(x.a.label);
    if(seen.has(k)) continue;
    seen.add(k);
    out.push(x.a);
    if(out.length >= Math.max(1, Number(limit) || 6)) break;
  }
  return out;
};

const isAdminBoundaryHit = (h) => {
  const cls = String(h?.class||'').toLowerCase();
  const typ = String(h?.type||'').toLowerCase();
  const at  = String(h?.addresstype||'').toLowerCase();
  if(cls === 'boundary' && (typ === 'administrative' || typ === 'political')) return true;
  if(at === 'country' || at === 'state' || at === 'region' || at === 'province' || at === 'county' || at === 'state_district') return true;
  return false;
};


const primaryLabel = (h) => {
  const n = String(h?.name || '').trim();
  if(n) return n;
  const dn = String(h?.display_name || '').trim();
  if(!dn) return '';
  return dn.split(',')[0].trim();
};

const normLoose = (s) => String(s||'')
  .toLowerCase()
  .replace(/\s+/g,' ')
  .replace(/[\u2019\'\u2018]/g,'')
  .replace(/[^a-z0-9\s,.-]/g,'')
  .trim();

const pickExactAdminHit = (list, rawQuery) => {
  const arr = Array.isArray(list) ? list : [];
  const qn = normLoose(rawQuery);
  if(!qn || !arr.length) return null;

  // First pass: exact primary label match on admin-like hits
  const candidates = arr.filter(h => {
    const at = String(h?.addresstype||'').toLowerCase();
    const cls = String(h?.class||'').toLowerCase();
    const typ = String(h?.type||'').toLowerCase();
    const isAdmin = (cls === 'boundary' && (typ === 'administrative' || typ === 'political')) ||
                    at === 'country' || at === 'state' || at === 'region' || at === 'province' || at === 'county' || at === 'state_district' ||
                    at === 'city' || at === 'town' || at === 'municipality';
    if(!isAdmin) return false;
    const pn = normLoose(primaryLabel(h));
    if(pn && pn === qn) return true;
    const dn = normLoose(String(h?.display_name||''));
    return dn.startsWith(qn + ',') || dn === qn;
  });

  if(!candidates.length) return null;

  // Prefer larger admin units for single-token queries (countries, regions, counties)
  candidates.sort((a,b) => {
    const ra = scoreNominatimHit(a);
    const rb = scoreNominatimHit(b);
    return ra - rb;
  });
  return candidates[0] || null;
};

const scoreNominatimHit = (h) => {
  if(h && h._aliasKey) return -10;
  const cls = String(h?.class||'').toLowerCase();
  const typ = String(h?.type||'').toLowerCase();
  const at = String(h?.addresstype||'').toLowerCase();

  // Lower is better
  let base = 9;
  if(cls === 'boundary' && (typ === 'administrative' || at === 'country' || at === 'region' || at === 'state')) base = 0;
  else if(at === 'country') base = 1;
  else if(at === 'state' || at === 'region' || at === 'province' || at === 'county') base = 2;
  else if(at === 'city' || at === 'town') base = 3;

  // Exact name match boost: when the user types "Spain" we should not return "Spain Street".
  const qrawLocal = String(($('textQuery') && $('textQuery').value) || '').trim();
  const qn = normLoose(qrawLocal);
  const pn = normLoose(primaryLabel(h));
  if(qn && pn && pn === qn){
    base -= 0.9;
    if(at === 'country') base -= 0.4;
    if(at === 'state' || at === 'region' || at === 'province' || at === 'county') base -= 0.2;
  }

  else if(at === 'village' || at === 'suburb') base = 4;

  // Strongly prefer true polygons for boundary-like results.
  // If Nominatim only returns a bbox, keep it as a fallback but rank it lower.
  const wantsPolygon = (base <= 2);
  const hasPoly = !!(h && h.geojson && (h.geojson.type === 'Polygon' || h.geojson.type === 'MultiPolygon'));
  if(wantsPolygon && !hasPoly) base += 1.2;

  // Country bias: prefer results in the users current country when we can infer it.
  const cc = String(h?.address?.country_code || '').trim().toLowerCase();
  if(userBias.countryCode && cc){
    if(cc === userBias.countryCode) base -= 0.45;
    else base += 0.20;
  }


  // If the query does not explicitly ask for USA, de-prioritise US hits to avoid burying common UK/Europe regions.
  const qraw = String(($('textQuery') && $('textQuery').value) || '').toLowerCase();
  const asksUS = (qraw.includes(' usa') || qraw.includes(',usa') || qraw.includes('united states') || qraw.includes(' us') || qraw.includes(',us'));
  if(cc === 'us' && !asksUS) base += 1.1;

  // Light Europe lift (golf travel intent), but still allow global results
  const euPref = new Set(['gb','ie','pt','es','fr','it','de','nl','be','dk','se','no','fi','gr','tr','cy','mt']);
  if(cc && euPref.has(cc)) base -= 0.25;

  // Proximity bias: prefer nearer matches, without hard filtering.
  const lat = Number(h?.lat);
  const lon = Number(h?.lon);
  if(Number.isFinite(userBias.lat) && Number.isFinite(userBias.lng) && Number.isFinite(lat) && Number.isFinite(lon)){
    const d = haversineKm(userBias.lat, userBias.lng, lat, lon);
    const add = Math.min(2.2, d / 700);
    base += add;
    if(cc && userBias.countryCode && cc === userBias.countryCode) base -= Math.min(0.6, add * 0.35);
  }

  return base;
};

const pickBestNominatimHit = (list) => {
  const arr = Array.isArray(list) ? list.slice() : [];
  if(!arr.length) return null;
  arr.sort((a,b) => scoreNominatimHit(a) - scoreNominatimHit(b));
  return arr[0] || null;
};

// Alias-aware hit picker: region aliases should prefer land boundaries and avoid water or misplaced POIs.
const pickBestAliasHit = (list, aliasCfg) => {
  const arr = Array.isArray(list) ? list.slice() : [];
  if(!arr.length) return null;

  const wantCC = String(aliasCfg?.countrycodes || '').toLowerCase().trim();
  const fbLat = Number(aliasCfg?.fallback?.lat);
  const fbLng = Number(aliasCfg?.fallback?.lng);

  const score = (h) => {
    let s = scoreNominatimHit(h);

    const cls = String(h?.class || '').toLowerCase();
    const typ = String(h?.type || '').toLowerCase();
    const at  = String(h?.addresstype || '').toLowerCase();
    const cc  = String(h?.address?.country_code || h?.country_code || '').toLowerCase();

    // Strongly prefer correct country if supplied
    if(wantCC && cc){
      if(cc === wantCC) s -= 0.8;
      else s += 1.2;
    }

    // Prefer boundaries over point-like results
    if(cls === 'boundary') s -= 0.9;
    if(isAdminBoundaryHit(h)) s -= 0.6;

    // Prefer relations, then ways, then nodes
    const osmType = String(h?.osm_type || '').toUpperCase();
    if(osmType === 'R') s -= 0.35;
    else if(osmType === 'W') s -= 0.15;

    // Penalise water and coastline-like matches for region aliases
    const looksLikeWater =
      (cls === 'natural' && (typ === 'bay' || typ === 'sea' || typ === 'water' || typ === 'coastline')) ||
      (cls === 'waterway') ||
      (at === 'bay' || at === 'sea' || at === 'water');
    if(looksLikeWater) s += 4.0;

    // If we have a curated fallback, prefer results near it
    const lat = Number(h?.lat), lon = Number(h?.lon);
    if(Number.isFinite(fbLat) && Number.isFinite(fbLng) && Number.isFinite(lat) && Number.isFinite(lon)){
      const d = haversineKm(fbLat, fbLng, lat, lon);
      s += Math.min(1.6, d / 220); // soft preference within a few hundred km
    }

    return s;
  };

  arr.sort((a,b) => score(a) - score(b));
  return arr[0] || null;
};



const closeAc = () => {
  const p = $('acPanel');
  if(p) { p.style.display = 'none'; p.innerHTML = ''; }
};

const formatHitLine = (hit) => {
  const disp = String(hit?.display_name || '').trim();
  if(!disp) return {top:'', sub:''};
  // Split into a strong lead plus a lighter remainder
  const parts = disp.split(',').map(s => s.trim()).filter(Boolean);
  const top = parts.slice(0,2).join(', ');
  const sub = parts.slice(2).join(', ');
  return { top, sub };
};

const renderAc = (hits) => {
  const panel = $('acPanel');
  if(!panel) return;
  panel.innerHTML = '';
  const list = Array.isArray(hits) ? hits.slice() : [];
  // Strong client-side re-ranking so common counties and regions do not get buried under far-away addresses
  list.sort((a,b) => scoreNominatimHit(a) - scoreNominatimHit(b));
  if(!list.length){ closeAc(); return; }

  for(const h of list){
    const {top, sub} = formatHitLine(h);
    const div = document.createElement('div');
    div.className = 'ac-item';
    div.innerHTML = `<div class="ac-top">${escapeHtml(top || String(h?.display_name||'').trim())}</div>` +
                    (sub ? `<div class="ac-sub">${escapeHtml(sub)}</div>` : '');
    div.addEventListener('mousedown', (e) => {
      // mousedown so it wins before input blur
      e.preventDefault();
      selectedTextHit = h;
      const name = String(h?.display_name || '').trim();
      if($('textQuery')) $('textQuery').value = name;
      applyRadiusHeuristic(h);
      closeAc();
      // Run immediately for fast feedback
      doTextSearch();
    });
    panel.appendChild(div);
  }
  panel.style.display = 'block';
};

const fetchTextSuggestions = async (q) => {
  initUserBias();
  const query = String(q || '').trim();
  if(query.length < 2){ closeAc(); return; }

  // Region alias suggestions (golf travel regions)
  // Lift curated regions to the top so users see the intended golf area first.
  const curated = [];
  const aliasList = findAliasSuggestions(query, 6);
  for(const alias of aliasList){
    curated.push({
      display_name: alias.label,
      class:'boundary',
      type:'region',
      addresstype:'region',
      _aliasKey: alias.key
    });
  }

  if(acAbort) acAbort.abort();
  acAbort = new AbortController();

  try{
    const vb = getNominatimViewboxParam();
    const url = 'https://nominatim.openstreetmap.org/search?format=json&polygon_geojson=1&addressdetails=1&extratags=1&namedetails=1&accept-language=en&limit=12'
      + (vb ? ('&viewbox=' + encodeURIComponent(vb) + '&bounded=0') : '')
      + '&q=' + encodeURIComponent(query);
    const res = await fetch(url, { headers:{'Accept':'application/json'}, signal: acAbort.signal });
    if(!res.ok) throw new Error('Geocode failed');
    const data = await res.json();
    lastTextHits = Array.isArray(data) ? data : [];
    // Rank by intent (boundary vs locality), then by user proximity and country bias.
    lastTextHits.sort((a,b) => {
      const sa = scoreNominatimHit(a);
      const sb = scoreNominatimHit(b);
      if(sa !== sb) return sa - sb;
      const na = String(a?.display_name||'');
      const nb = String(b?.display_name||'');
      return na.localeCompare(nb);
    });
    // Add curated items to the top if they are not already present
    const merged = [...curated];
    for(const h of lastTextHits){
      const dn = String(h?.display_name||'').toLowerCase();
      if(merged.some(x => String(x.display_name||'').toLowerCase() === dn)) continue;
      merged.push(h);
    }
    lastTextHits = merged;
    renderAc(lastTextHits);
  } catch(e){
    if(String(e?.name) === 'AbortError') return;
    closeAc();
  }
};

const applyRadiusHeuristic = (hit) => {
  const r = $('radiusSelect');
  if(!r || !hit) return;
  if(radiusOverride) return;

  const cls = String(hit.class || '').toLowerCase();
  const typ = String(hit.type || '').toLowerCase();
  const addType = String(hit.addresstype || '').toLowerCase();
  const addr = hit.address || {};

  const hasHouse = !!(addr.house_number || addr.road || addr.building);

  const isCountry = (addType === 'country' || (cls === 'boundary' && typ === 'administrative' && (addr.country && !addr.state && !addr.county && !addr.city && !addr.town)));
  const isRegion = (addType === 'state' || addType === 'region' || addType === 'county' || addType === 'province' || addType === 'state_district');
  const isLocality = (addType === 'city' || addType === 'town' || addType === 'village' || addType === 'suburb' || addType === 'hamlet' || addType === 'neighbourhood');

  if(hasHouse || addType === 'house' || addType === 'building' || typ === 'house' || typ === 'building' || cls === 'building'){
    r.value = '0';
    return;
  }
  if(isCountry || isRegion){
    // Prefer using the region boundary bbox (no radius)
    r.value = '0';
    return;
  }
  if(isLocality){
    // Default to 10 miles to feel useful without being overwhelming
    r.value = '10';
    return;
  }
  // Fallback
  r.value = '5';
};

const milesToKm = (m) => (Number(m || 0) * 1.609344);

const bboxToPolygon = (bb) => {
  // Nominatim returns [south, north, west, east] as strings
  if(!Array.isArray(bb) || bb.length < 4) return null;
  const south = Number(bb[0]), north = Number(bb[1]), west = Number(bb[2]), east = Number(bb[3]);
  if(!Number.isFinite(south) || !Number.isFinite(north) || !Number.isFinite(west) || !Number.isFinite(east)) return null;
  return turf.polygon([[
    [west, south],
    [east, south],
    [east, north],
    [west, north],
    [west, south]
  ]]).geometry;
};


const simplifyBoundaryGeometry = (gj) => {
  if(!gj) return null;
  if(!(gj.type === 'Polygon' || gj.type === 'MultiPolygon')) return null;
  try{
    // Simplify very complex boundaries so they render quickly
    const feat = turf.feature(gj);
    const b = turf.bbox(feat);
    const span = Math.max(Math.abs(b[2]-b[0]), Math.abs(b[3]-b[1]));
    const tol = span > 5 ? 0.05 : span > 1 ? 0.01 : 0.002; // degrees
    const simp = turf.simplify(feat, {tolerance:tol, highQuality:false});
    return simp.geometry || gj;
  } catch(e){
    return gj;
  }
};

const fetchNominatimDetailsPolygon = async (hit) => {
  try{
    const osmTypeRaw = String(hit?.osm_type || '').trim().toUpperCase();
    const osmId = Number(hit?.osm_id);
    if(!osmTypeRaw || !Number.isFinite(osmId)) return null;
    const osmtype = osmTypeRaw[0]; // N, W, R
    const url = 'https://nominatim.openstreetmap.org/details.php?format=json&polygon_geojson=1&osmtype=' +
      encodeURIComponent(osmtype) + '&osmid=' + encodeURIComponent(String(osmId));
    const res = await fetch(url, {headers:{'Accept':'application/json'}});
    if(!res.ok) return null;
    const data = await res.json();
    const gj = data?.geometry?.geojson || data?.geometry || data?.geojson || null;
    const geom = (gj && (gj.type === 'Polygon' || gj.type === 'MultiPolygon')) ? gj : null;
    return simplifyBoundaryGeometry(geom);
  } catch(e){
    return null;
  }
};


// --- Region boundary resolution (Wikipedia → Wikidata → OSM relation geometry) ---
// This dramatically improves vernacular regions (Costa del Sol, Costa Brava, etc) that Nominatim may return as a point or even as a sea feature.
const _wikiQidCache = new Map();
const _wikidataP402Cache = new Map();
const _osmRelationGeomCache = new Map();

const fetchWikipediaWikibaseItem = async (title) => {
  const t = String(title || '').trim();
  if(!t) return null;
  const cacheKey = t.toLowerCase();
  if(_wikiQidCache.has(cacheKey)) return _wikiQidCache.get(cacheKey);

  try{
    const url = 'https://en.wikipedia.org/w/api.php?action=query&format=json&origin=*&prop=pageprops&redirects=1&titles=' + encodeURIComponent(t);
    const res = await fetch(url, {headers:{'Accept':'application/json'}});
    if(!res.ok) { _wikiQidCache.set(cacheKey, null); return null; }
    const data = await res.json();
    const pages = data?.query?.pages || {};
    const page = Object.values(pages)[0] || null;
    const qid = page?.pageprops?.wikibase_item || null;
    _wikiQidCache.set(cacheKey, qid);
    return qid;
  } catch(e){
    _wikiQidCache.set(cacheKey, null);
    return null;
  }
};

const fetchWikidataP402 = async (qid) => {
  const id = String(qid || '').trim();
  if(!id) return null;
  if(_wikidataP402Cache.has(id)) return _wikidataP402Cache.get(id);

  try{
    const url = 'https://www.wikidata.org/w/api.php?action=wbgetentities&format=json&origin=*&props=claims&ids=' + encodeURIComponent(id);
    const res = await fetch(url, {headers:{'Accept':'application/json'}});
    if(!res.ok) { _wikidataP402Cache.set(id, null); return null; }
    const data = await res.json();
    const ent = data?.entities?.[id] || null;
    const claims = ent?.claims || {};
    const p402 = claims?.P402 || null;
    const relId = p402?.[0]?.mainsnak?.datavalue?.value || null; // numeric relation id
    const relNum = relId ? Number(relId) : NaN;
    const out = Number.isFinite(relNum) ? String(relNum) : null;
    _wikidataP402Cache.set(id, out);
    return out;
  } catch(e){
    _wikidataP402Cache.set(id, null);
    return null;
  }
};


const _wikidataGeoShapeTitleCache = new Map();
const _commonsGeoJSONGeomCache = new Map();

// Wikidata P3896 (geoshape) is the most reliable way to get a real region outline
// for vernacular travel regions that are not strict admin boundaries in OSM.
const fetchWikidataP3896 = async (qid) => {
  const id = String(qid || '').trim();
  if(!id) return null;
  if(_wikidataGeoShapeTitleCache.has(id)) return _wikidataGeoShapeTitleCache.get(id);

  try{
    const url = 'https://www.wikidata.org/w/api.php?action=wbgetentities&format=json&origin=*&props=claims&ids=' + encodeURIComponent(id);
    const res = await fetch(url, {headers:{'Accept':'application/json'}});
    if(!res.ok) { _wikidataGeoShapeTitleCache.set(id, null); return null; }
    const data = await res.json();
    const ent = data?.entities?.[id] || null;
    const claims = ent?.claims || {};
    const p3896 = claims?.P3896 || null;
    const raw = p3896?.[0]?.mainsnak?.datavalue?.value || null; // like "Costa_del_Sol.map"
    const title = raw ? String(raw).trim() : null;
    _wikidataGeoShapeTitleCache.set(id, title || null);
    return title || null;
  } catch(e){
    _wikidataGeoShapeTitleCache.set(id, null);
    return null;
  }
};

const geojsonToPolygonGeometry = (gj) => {
  if(!gj) return null;

  // GeoJSON returned by Wikimedia geoshapes can be FeatureCollection, Feature, or Geometry
  try{
    if(gj.type === 'FeatureCollection' && Array.isArray(gj.features) && gj.features.length){
      // Combine into a single feature when possible
      const combined = turf.combine(gj);
      const g = combined?.features?.[0]?.geometry || null;
      if(g && (g.type === 'Polygon' || g.type === 'MultiPolygon')) return g;
      // Fallback: first polygon feature
      for(const f of gj.features){
        const g2 = f?.geometry || null;
        if(g2 && (g2.type === 'Polygon' || g2.type === 'MultiPolygon')) return g2;
      }
      return null;
    }

    if(gj.type === 'Feature'){
      const g = gj.geometry || null;
      if(g && (g.type === 'Polygon' || g.type === 'MultiPolygon')) return g;
      return null;
    }

    if(gj.type === 'Polygon' || gj.type === 'MultiPolygon') return gj;
    return null;
  } catch(e){
    return null;
  }
};

const fetchCommonsGeoJSONGeometry = async (title) => {
  const t = String(title || '').trim();
  if(!t) return null;

  const key = String(t).toLowerCase();
  if(_commonsGeoJSONGeomCache.has(key)) return _commonsGeoJSONGeomCache.get(key);

  const tryFetch = async (url) => {
    const res = await fetch(url, { headers:{ 'Accept':'application/json' } });
    if(!res.ok) return null;
    let obj = null;
    try{ obj = await res.json(); }
    catch(e){
      try{
        const txt = await res.text();
        obj = JSON.parse(txt);
      } catch(e2){ return null; }
    }
    if(obj && obj.data) obj = obj.data;
    const geom = geojsonToPolygonGeometry(obj);
    return simplifyBoundaryGeometry(geom);
  };

  try{
    const fileTitle = t.toLowerCase().startsWith('data:') ? t : ('Data:' + t);
    const pageUrl = 'https://commons.wikimedia.org/wiki/' + encodeURIComponent(fileTitle) + '?format=json';
    let geom = await tryFetch(pageUrl);
    if(!geom){
      const rawUrl = 'https://commons.wikimedia.org/wiki/' + encodeURIComponent(fileTitle) + '?action=raw';
      geom = await tryFetch(rawUrl);
    }

    _commonsGeoJSONGeomCache.set(key, geom || null);
    return geom || null;
  } catch(e){
    _commonsGeoJSONGeomCache.set(key, null);
    return null;
  }
};

const fetchWikidataGeoShapeGeometry = async (qid) => {
  const title = await fetchWikidataP3896(qid);
  if(!title) return null;
  return await fetchCommonsGeoJSONGeometry(title);
};

const fetchOverpassRelationGeometry = async (relationId) => {
  const rid = String(relationId || '').trim();
  if(!rid) return null;
  if(_osmRelationGeomCache.has(rid)) return _osmRelationGeomCache.get(rid);

  // Use the app configured Overpass endpoint to respect the same runtime behaviour.
  // We ask for a single relation with geometry. Then we assemble MultiPolygon rings from member ways when possible.
  try{
    const q = `
      [out:json][timeout:25];
      relation(${rid});
      out body;
      >;
      out geom;
    `;
    const url = OVERPASS_URL + '?data=' + encodeURIComponent(q);
    const res = await fetch(url, {headers:{'Accept':'application/json'}});
    if(!res.ok) { _osmRelationGeomCache.set(rid, null); return null; }
    const data = await res.json();
    const rel = (data?.elements || []).find(e => e.type === 'relation' && String(e.id) === String(rid)) || null;
    const ways = (data?.elements || []).filter(e => e.type === 'way' && Array.isArray(e.geometry));
    if(!rel || !ways.length){ _osmRelationGeomCache.set(rid, null); return null; }

    // Build closed rings from ways where possible.
    const rings = [];
    for(const w of ways){
      const pts = (w.geometry || []).map(p => [Number(p.lon), Number(p.lat)]).filter(x => Number.isFinite(x[0]) && Number.isFinite(x[1]));
      if(pts.length < 4) continue;
      const first = pts[0], last = pts[pts.length-1];
      const closed = (Math.abs(first[0]-last[0]) < 1e-9) && (Math.abs(first[1]-last[1]) < 1e-9);
      if(!closed) pts.push(first);
      rings.push(pts);
    }

    // If we got at least one ring, treat it as MultiPolygon with one polygon (best-effort).
    // This is not a full relation assembler, but it is enough for most place boundaries that are already contiguous.
    let geom = null;
    if(rings.length){
      // Choose the largest ring by bbox area as the outer boundary.
      const ringStats = rings.map(r => {
        const lons = r.map(p => p[0]), lats = r.map(p => p[1]);
        const minx = Math.min(...lons), maxx = Math.max(...lons), miny = Math.min(...lats), maxy = Math.max(...lats);
        return {ring:r, area:(maxx-minx)*(maxy-miny)};
      }).sort((a,b) => b.area - a.area);
      geom = { type:'Polygon', coordinates:[ ringStats[0].ring ] };
    }

    const simp = simplifyBoundaryGeometry(geom);
    _osmRelationGeomCache.set(rid, simp);
    return simp;
  } catch(e){
    _osmRelationGeomCache.set(rid, null);
    return null;
  }
};


const _wikidataOverpassRelIdCache = new Map();

const fetchOverpassRelationIdByWikidata = async (qid) => {
  const id = String(qid || '').trim();
  if(!id) return null;
  if(_wikidataOverpassRelIdCache.has(id)) return _wikidataOverpassRelIdCache.get(id);

  try{
    const q = `
      [out:json][timeout:20];
      relation["wikidata"="${id}"];
      out ids;
    `;
    const url = OVERPASS_URL + '?data=' + encodeURIComponent(q);
    const res = await fetch(url, {headers:{'Accept':'application/json'}});
    if(!res.ok){ _wikidataOverpassRelIdCache.set(id, null); return null; }
    const data = await res.json();
    const rel = (data?.elements || []).find(e => e.type === 'relation' && Number.isFinite(Number(e.id))) || null;
    const rid = rel ? String(rel.id) : null;
    _wikidataOverpassRelIdCache.set(id, rid);
    return rid;
  } catch(e){
    _wikidataOverpassRelIdCache.set(id, null);
    return null;
  }
};

const _isoOverpassRelIdCache = new Map();

const fetchOverpassRelationIdByISO = async (alpha2) => {
  const cc = String(alpha2 || '').trim().toUpperCase();
  if(!cc || cc.length !== 2) return null;
  if(_isoOverpassRelIdCache.has(cc)) return _isoOverpassRelIdCache.get(cc);

  try{
    const q = `
      [out:json][timeout:20];
      (
        relation["boundary"="administrative"]["ISO3166-1:alpha2"="${cc}"];
        relation["boundary"="administrative"]["ISO3166-1"="${cc}"];
      );
      out ids;
    `;
    const url = OVERPASS_URL + '?data=' + encodeURIComponent(q);
    const res = await fetch(url, {headers:{'Accept':'application/json'}});
    if(!res.ok){ _isoOverpassRelIdCache.set(cc, null); return null; }
    const data = await res.json();
    const rel = (data?.elements || []).find(e => e.type === 'relation') || null;
    const out = rel?.id ? String(rel.id) : null;
    _isoOverpassRelIdCache.set(cc, out);
    return out;
  } catch(e){
    _isoOverpassRelIdCache.set(cc, null);
    return null;
  }
};

const isCountryLikeHit = (hit) => {
  const at = String(hit?.addresstype || '').toLowerCase();
  const t = String(hit?.type || '').toLowerCase();
  return at === 'country' || t === 'country';
};


const resolveRegionAliasGeometry = async (aliasCfg) => {
  if(!aliasCfg) return null;

  const qids = Array.isArray(aliasCfg.qids) ? aliasCfg.qids.filter(Boolean) : [];

  // 1) Wikidata QID -> Overpass relation with wikidata=* tag (most reliable when it exists)
  for(const qid of qids){
    const rid = await fetchOverpassRelationIdByWikidata(qid);
    if(rid){
      aliasCfg._resolvedRelId = Number(rid);
      const g = await fetchOverpassRelationGeometry(rid);
      if(g) return g;
    }
  }

  // 2) Wikidata QID -> OSM relation id (P402) -> Overpass relation geometry (helpful when wikidata=* is missing in OSM)
  for(const qid of qids){
    const relId = await fetchWikidataP402(qid);
    if(relId){
      aliasCfg._resolvedRelId = Number(relId);
      const g = await fetchOverpassRelationGeometry(relId);
      if(g) return g;
    }
  }


  // 2.5) Wikidata geoshape (P3896) -> Wikimedia GeoJSON outline (best for vernacular regions like Costa del Sol)
  for(const qid of qids){
    const gShape = await fetchWikidataGeoShapeGeometry(qid);
    if(gShape) return gShape;
  }

  // 3) Wikipedia title -> Wikidata QID -> Overpass relation id / P402 (best effort, avoids alias table gaps)
  const title = aliasCfg.wikipediaTitle || aliasCfg.query || aliasCfg.label || '';
  const qid2 = await fetchWikipediaWikibaseItem(title);
  if(qid2){

    const gShape2 = await fetchWikidataGeoShapeGeometry(qid2);
    if(gShape2) return gShape2;

    const rid2 = await fetchOverpassRelationIdByWikidata(qid2);
    if(rid2){
      aliasCfg._resolvedRelId = Number(rid2);
      const g2 = await fetchOverpassRelationGeometry(rid2);
      if(g2) return g2;
    }
    const relId2 = await fetchWikidataP402(qid2);
    if(relId2){
      aliasCfg._resolvedRelId = Number(relId2);
      const g3 = await fetchOverpassRelationGeometry(relId2);
      if(g3) return g3;
    }
  }

  // 4) Nominatim search + details polygon (works when there is an OSM relation or way but Overpass lookup is weak)
  try{
    const q = String(aliasCfg.query || aliasCfg.label || '');
    const url = 'https://nominatim.openstreetmap.org/search?format=jsonv2&addressdetails=1&namedetails=1&limit=8&q=' +
      encodeURIComponent(q) +
      (aliasCfg.countrycodes ? ('&countrycodes=' + encodeURIComponent(aliasCfg.countrycodes)) : '') +
      (userBias?.lat && userBias?.lng ? ('&viewbox=' + encodeURIComponent(buildViewbox(userBias.lat, userBias.lng, 2.5)) + '&bounded=0') : '');
    const res = await fetch(url, { headers:{'Accept':'application/json'} });
    if(res.ok){
      const data = await res.json();
      const hit = Array.isArray(data) ? data[0] : null;
      if(hit){
        // Prefer polygon from details endpoint (more consistent than search response)
        const det = await fetchNominatimDetailsPolygon(hit);
        if(det) return det;

        const gj = hit.geojson;
        const geom = (gj && (gj.type === 'Polygon' || gj.type === 'MultiPolygon')) ? gj : null;
        const simp = simplifyBoundaryGeometry(geom);
        if(simp) return simp;
      }
    }
  } catch(e){}

  return null;
};

const hitToGeometryAsync = async (hit) => {
  if(!hit) return null;
  const gj = hit.geojson;
  const simp = simplifyBoundaryGeometry(gj);
  if(simp) return simp;

  // If Nominatim did not return a polygon, try the details endpoint to pull geometry by OSM id.
// This is critical for cities, counties, regions, and many travel vernacular areas worldwide.
  {
    const det = await fetchNominatimDetailsPolygon(hit);
    if(det) return det;
  }

  // Avoid rigid bbox squares for regions. If we only have a bbox, cover it with a circle.
  const bb = hit.boundingbox || null;
  if(Array.isArray(bb) && bb.length >= 4){
    const south = Number(bb[0]), north = Number(bb[1]), west = Number(bb[2]), east = Number(bb[3]);
    if(Number.isFinite(south) && Number.isFinite(north) && Number.isFinite(west) && Number.isFinite(east)){
      const cx = (west + east) / 2;
      const cy = (south + north) / 2;
      const diagKm = turf.distance([west, south], [east, north], {units:'kilometers'});
      const radKm = Math.max(12, Math.min(diagKm / 2, 1200));
      const circle = turf.circle([cx, cy], radKm, {steps:72, units:'kilometers'});
      return circle.geometry;
    }
  }

  return null;
};


const setTextMarker = (lat, lng) => {
  if(!map) return;
  if(textSearchMarker) { map.removeLayer(textSearchMarker); textSearchMarker = null; }
  textSearchMarker = L.marker([lat, lng], {opacity:0.95});
  textSearchMarker.addTo(map);
};

const showTextArea = (geometry) => {
  if(!map) return;
  if(textAreaLayer){ map.removeLayer(textAreaLayer); textAreaLayer = null; }
  if(!geometry) return;

  try{
    const feat = { type:'Feature', properties:{}, geometry };
    textAreaLayer = L.geoJSON(feat, {
      style:{ weight:2, opacity:0.95, fillOpacity:0.10 }
    }).addTo(map);
  } catch(e){
    // ignore
  }
};


const doTextSearch = async () => {
  if(mode !== 'text') return;

  const qEl = $('textQuery');
  const q = String((qEl && qEl.value) || '').trim();
  if(!q){
    setLivePill('Type a location to search');
    return;
  }

  // Latest action wins: reset previous selection and any drawn shapes
  clearArea();
  setLivePill('Searching location');

  const radiusEl = $('radiusSelect');

  // Prefer an explicitly selected suggestion when available
  let hit = null;
  if(selectedTextHit){
    hit = selectedTextHit;
  }


    // Alias selections need a more deliberate resolve than a naive first hit.
  // We apply country hints and prefer boundaries so regions behave like regions.
  let aliasCfg = null;
  if(hit && hit._aliasKey){
    aliasCfg = REGION_ALIASES.find(x => normKey(x.key) === normKey(hit._aliasKey)) || null;
    hit = null;
  }

  // If the user presses Enter without selecting a suggestion, still catch exact alias matches
  if(!aliasCfg){
    const direct = REGION_ALIASES.find(x => normKey(x.key) === normKey(q)) || null;
    if(direct){
      aliasCfg = direct;
      hit = null;
    }
  }


  let qToGeocode = q;
  let countryHint = '';
  activeTextAliasCfg = aliasCfg || null;
  if(aliasCfg){
    qToGeocode = String(aliasCfg.query || q).trim() || q;
    countryHint = String(aliasCfg.countrycodes || '').trim();
  }

  // For curated region aliases, do not rely on Nominatim point hits when a true boundary exists.
  // If the user has NOT manually overridden the radius, we treat the alias as an area-first search.
  if(aliasCfg && !radiusOverride){
    const aliasGeom = await resolveRegionAliasGeometry(aliasCfg);
    if(aliasGeom){
      geom = aliasGeom;
      // Use Overpass area id when the alias resolves to an OSM relation (more reliable than huge polygons for countries/regions)
      if(Number.isFinite(Number(aliasCfg?._resolvedRelId))){ geomAreaId = 3600000000 + Number(aliasCfg._resolvedRelId); }
      else { geomAreaId = null; }
      // Clear any pin marker for regions
      if(textSearchMarker){ map.removeLayer(textSearchMarker); textSearchMarker = null; }
      // Fit map to boundary
      try{
        const b = turf.bbox({type:'Feature', properties:{}, geometry:geom});
        if(Array.isArray(b) && b.length === 4){
          map.fitBounds([[b[1], b[0]],[b[3], b[2]]], {padding:[18,18]});
        }
      } catch(e){ /* ignore */ }
      setLivePill('Loading courses for this area');
      showTextArea(geom);
      await fetchLive();
      refresh();
      return;
    }
  }


  // If not chosen from suggestions, geocode now

  if(!hit){
    try{
            const cc = countryHint ? ('&countrycodes=' + encodeURIComponent(countryHint)) : '';
      const url = 'https://nominatim.openstreetmap.org/search?format=json&polygon_geojson=1&addressdetails=1&limit=10' + cc + '&q=' + encodeURIComponent(qToGeocode);
      const res = await fetch(url, {headers:{'Accept':'application/json'}});
      const data = await res.json();
      if(Array.isArray(data) && data.length){
        hit = aliasCfg ? pickBestAliasHit(data, aliasCfg) : (pickExactAdminHit(data, qToGeocode) || pickBestNominatimHit(data));
      }

// Alias hygiene: reject water features or obviously non-region matches.
// Region aliases are intended to represent land areas that contain playable golf courses.
if(aliasCfg && hit){
  const cls = String(hit.class||'').toLowerCase();
  const typ = String(hit.type||'').toLowerCase();
  const at  = String(hit.addresstype||'').toLowerCase();
  const ccHit = String(hit?.address?.country_code || hit?.country_code || '').toLowerCase();
  const ccWanted = String(countryHint || '').toLowerCase();
  const looksLikeWater =
    (cls === 'natural' && (typ === 'bay' || typ === 'sea' || typ === 'water' || typ === 'coastline')) ||
    (cls === 'waterway') ||
    (at === 'bay' || at === 'sea');
  // If we asked for a country hint and this hit is not in that country, discard it.
  const wrongCountry = !!(ccWanted && ccHit && ccHit !== ccWanted);
  if(looksLikeWater || wrongCountry) hit = null;
}

// If the best match is far from our curated fallback centre, prefer fallback.
// This prevents cases like Costa del Sol jumping inland or into the sea.
if(aliasCfg && hit && aliasCfg.fallback){
  const fbLat = Number(aliasCfg.fallback.lat);
  const fbLng = Number(aliasCfg.fallback.lng);
  const lat = Number(hit.lat), lng = Number(hit.lon);
  if(Number.isFinite(fbLat) && Number.isFinite(fbLng) && Number.isFinite(lat) && Number.isFinite(lng)){
    const d = haversineKm(fbLat, fbLng, lat, lng);
    if(d > 260) hit = null;
  }
}



      // Alias safeguard: if Nominatim returns an implausible match (eg drops into the sea or the wrong city),
      // prefer our curated fallback so users still get the intended golf region coverage.
      if(aliasCfg && hit && aliasCfg.fallback && Number.isFinite(Number(aliasCfg.fallback.lat)) && Number.isFinite(Number(aliasCfg.fallback.lng))){
        const fLat = Number(aliasCfg.fallback.lat);
        const fLng = Number(aliasCfg.fallback.lng);
        const hLat = Number(hit.lat), hLng = Number(hit.lon);
        if(Number.isFinite(hLat) && Number.isFinite(hLng)){
          const dKm = haversineKm(fLat, fLng, hLat, hLng);
          if(dKm > 160){
            hit = null;
          }
        }
      }
    } catch(e){
      setLivePill('Search failed');
      return;
    }
  }

  if(!hit){
    if(aliasCfg && aliasCfg.fallback && Number.isFinite(Number(aliasCfg.fallback.lat)) && Number.isFinite(Number(aliasCfg.fallback.lng))){
      const lat = Number(aliasCfg.fallback.lat);
      const lng = Number(aliasCfg.fallback.lng);
      const rm = Number(aliasCfg.fallback.radiusMiles || 50);
      setTextMarker(lat, lng);
      const circle = turf.circle([lng, lat], milesToKm(rm), {steps:72, units:'kilometers'});
      geomAreaId = null;
      geomAreaId = null;
      geom = circle.geometry;
      const b = turf.bbox(circle);
      map.fitBounds([[b[1], b[0]],[b[3], b[2]]], {padding:[18,18]});
      setLivePill('Loading courses for this area');
      showTextArea(geom);
      await fetchLive();
      refresh();
      return;
    }
    
    // Region alias fallback: still run a sensible region-scale search area.
    if(aliasCfg && aliasCfg.fallback){
      hit = {
        lat: String(aliasCfg.fallback.lat),
        lon: String(aliasCfg.fallback.lng),
        class: 'place',
        type: 'region',
        addresstype: 'region',
        display_name: String(aliasCfg.label || qToGeocode || q),
        _isAliasFallback: true
      };
    } else {
      setLivePill('No matches. Try a broader location.');
      activeTextAliasCfg = null;
      return;
    }
  }

  // Tune default radius based on intent (address vs city vs region vs country)
  applyRadiusHeuristic(hit);

  const lat = Number(hit.lat), lng = Number(hit.lon);
  if(!Number.isFinite(lat) || !Number.isFinite(lng)){
    setLivePill('No usable coordinates for that search.');
    return;
  }

  let radiusMiles = radiusEl ? Number(radiusEl.value || 5) : 5;

  const addType = String(hit.addresstype || '').toLowerCase();
  const isCountry = addType === 'country';
  const isRegion = (addType === 'state' || addType === 'region' || addType === 'county' || addType === 'province' || addType === 'state_district');

  // Build the selection geometry used by Overpass.
// Principle: user intent wins. If the user has manually chosen a radius, do not override it.
// For region-like searches, we should behave like countries: prefer true boundaries (polygons) and only fall back to circles when unavoidable.
const isBoundaryLike =
  (isCountry || isRegion) ||
  isAdminBoundaryHit(hit) ||
  (String(hit.class||'').toLowerCase() === 'boundary') ||
  (String(hit.type||'').toLowerCase() === 'administrative');

if(!radiusOverride && isBoundaryLike){
  // Prefer Overpass area queries for administrative boundaries (countries, counties, regions).
  // When available, use an Overpass area id (3600000000 + relation id) to avoid polygon string limits/timeouts.
  const hitOsmType = String(hit?.osm_type || '').trim().toUpperCase();
  const hitOsmId = Number(hit?.osm_id);
  geomAreaId = (hitOsmType === 'R' && Number.isFinite(hitOsmId)) ? (3600000000 + hitOsmId) : null;

  // If the selected hit is not a relation (or Nominatim gave a point), try to recover the boundary relation id.
  // 1) Use Wikidata when present.
  if(!geomAreaId){
    const qid = hit?.extratags?.wikidata || hit?.wikidata || null;
    if(qid){
      const relId = await fetchOverpassRelationIdByWikidata(qid);
      const relNum = relId ? Number(relId) : NaN;
      if(Number.isFinite(relNum)) geomAreaId = 3600000000 + relNum;
    }
  }

  // 2) For countries, use ISO country codes as a reliable fallback.
  if(!geomAreaId && isCountryLikeHit(hit)){
    const cc = String(hit?.address?.country_code || hit?.country_code || '').trim().toUpperCase();
    if(cc){
      const relId = await fetchOverpassRelationIdByISO(cc);
      const relNum = relId ? Number(relId) : NaN;
      if(Number.isFinite(relNum)) geomAreaId = 3600000000 + relNum;
    }
  }
  // Area-first intent: do not drop a pin marker.
  if(textSearchMarker){ map.removeLayer(textSearchMarker); textSearchMarker = null; }

  const gg = await hitToGeometryAsync(hit);
  if(gg){
    geom = gg;
    const b = turf.bbox(turf.feature(geom));
    map.fitBounds([[b[1], b[0]],[b[3], b[2]]], {padding:[18,18]});
    setLivePill('Loading courses for this area');
    showTextArea(geom);
  } else if(Array.isArray(hit.boundingbox) && hit.boundingbox.length >= 4){
    // If we only have a bbox and no polygon, cover the bbox (and avoid tiny circles)
    const south = Number(hit.boundingbox[0]), north = Number(hit.boundingbox[1]);
    const west = Number(hit.boundingbox[2]), east = Number(hit.boundingbox[3]);
    if(Number.isFinite(south) && Number.isFinite(north) && Number.isFinite(west) && Number.isFinite(east)){
      const cx = (west + east) / 2;
      const cy = (south + north) / 2;
      const diagKm = turf.distance([west, south], [east, north], {units:'kilometers'});
      const radKm = Math.max(5, Math.min(diagKm / 2, 1200)); // minimum makes counties feel like counties
      const circle = turf.circle([cx, cy], radKm, {steps:72, units:'kilometers'});
      geomAreaId = null;
      geom = circle.geometry;
      const b = turf.bbox(circle);
      map.fitBounds([[b[1], b[0]],[b[3], b[2]]], {padding:[18,18]});
      setLivePill('Loading courses for this area');
      showTextArea(geom);
    }
  } else if(activeTextAliasCfg && activeTextAliasCfg.fallback && hit && !radiusOverride){
    // Curated region alias fallback: use a sensible region-scale circle, not a pin.
    const fb = activeTextAliasCfg.fallback;
    const radMiles = Number(fb.radiusMiles || 45);
    const radKm = milesToKm(Math.max(10, radMiles));
    const cx = Number(fb.lng), cy = Number(fb.lat);
    if(Number.isFinite(cx) && Number.isFinite(cy)){
      const circle = turf.circle([cx, cy], radKm, {steps:72, units:'kilometers'});
      geom = circle.geometry;
      map.fitBounds(turf.bbox(circle), {padding:[18,18]});
      setLivePill('Loading courses for this area');
      showTextArea(geom);
    }
  }
}

if(!geom){
  // Non-boundary searches: keep a pin for orientation
  setTextMarker(lat, lng);
}

// If we already have a boundary polygon (country, county, region, admin area), do not overwrite it with a radius circle.
// A radius circle is only used when we could not resolve a usable boundary geometry, or when the user has explicitly overridden radius.
if(!geom){
  if(radiusMiles === 0){
    // Exact point search: keep it tight so results feel relevant
    const circle = turf.circle([lng, lat], milesToKm(0.25), {steps:72, units:'kilometers'});
    geom = circle.geometry;
    const b = turf.bbox(circle);
    map.fitBounds([[b[1], b[0]],[b[3], b[2]]], {padding:[18,18]});
    setLivePill('Loading courses near this point');
    showTextArea(geom);
  } else {
    const circle = turf.circle([lng, lat], milesToKm(radiusMiles), {steps:72, units:'kilometers'});
    geom = circle.geometry;
    const b = turf.bbox(circle);
    map.fitBounds([[b[1], b[0]],[b[3], b[2]]], {padding:[18,18]});
    setLivePill('Loading courses within ' + radiusMiles + ' miles');
    showTextArea(geom);
  }
}

// Load courses using the same Overpass pipeline
  await fetchLive();
  refresh();
};

  
  // Near me search (client geolocation). Draws a 10 mile radius and loads courses within it.
  let nearMeMarker = null;

  const doNearMe = () => {
    if(!ensureLeaflet()) return;
    if(!navigator.geolocation){
      setLivePill('Location not available in this browser');
      return;
    }

    setLivePill('Finding courses near you');

    const g0 = $('drawGuide');
    if(g0){ g0.style.display = ''; g0.textContent = 'Finding courses near you'; }

    navigator.geolocation.getCurrentPosition((pos) => {
      const lat = Number(pos && pos.coords && pos.coords.latitude);
      const lng = Number(pos && pos.coords && pos.coords.longitude);
      if(!Number.isFinite(lat) || !Number.isFinite(lng)){
        setLivePill('Location unavailable');
        return;
      }

      // Clear any existing selection and draw a 10 mile radius
      try{ clearArea(); } catch(e){}

      mapToolArmed = true;
      const pill = $('livePill');
      if(pill) pill.style.display = '';

      if(drawn) drawn.clearLayers();
      if(map && nearMeMarker){ try{ map.removeLayer(nearMeMarker); } catch(e){} nearMeMarker = null; }

      const radiusM = 16093.44; // 10 miles in meters
      const circle = L.circle([lat, lng], { radius: radiusM });
      if(drawn) drawn.addLayer(circle);
      const g = $('drawGuide');
      if(g){ g.style.display = ''; g.textContent = 'Area selected'; }

      nearMeMarker = L.marker([lat, lng]);
      if(map) nearMeMarker.addTo(map);

      if(map){
        try{ map.fitBounds(circle.getBounds(), { padding:[18,18] }); }
        catch(e){ map.setView([lat, lng], 11, {animate:true}); }
      }

      const poly = turf.circle([lng, lat], 16.09344, { steps:64, units:'kilometers' });
      geom = poly.geometry;

      fetchLive();
      refresh();
    }, (err) => {
      // Keep the page usable even if location is denied.
      setLivePill('Location permission denied');
      console.warn('Geolocation error', err);
    }, {
      enableHighAccuracy: true,
      timeout: 12000,
      maximumAge: 60000
    });
  };


const setMode = (m) => {
  mode = m;
  mapToolArmed = (m === 'map') ? false : mapToolArmed;

  // Switching modes resets the current selection. Latest action wins.
  clearArea();
  document.body.classList.toggle('mode-map', m === 'map');
  document.body.classList.toggle('mode-text', m === 'text');

  // Map drawing tools are only relevant in map mode
  if(map && drawControl){
    if(m === 'text'){
      try{ map.removeControl(drawControl); } catch(e){}
      const g = $('drawGuide'); if(g) g.style.display = 'none';
    } else {
      // Re add if missing
      const has = document.querySelector('.leaflet-draw');
      if(!has){ try{ map.addControl(drawControl); } catch(e){} }
      const g = $('drawGuide'); if(g) g.style.display = '';
    }
  }

  $('btnMap').classList.toggle('active', m === 'map');
  $('btnText').classList.toggle('active', m === 'text');
  $('btnNear') && $('btnNear').classList.toggle('active', m === 'near');
  $('modePrompt').style.display = 'none';

  const pl = $('pageLayout');
  const sc = $('sideCol');

  // Both modes use the same map and the same sidebar layout
  if(pl) pl.classList.add('with-filters');
  if(sc) sc.style.display = 'block';
  $('filtersWrap').style.display = 'none';

  $('mapWrap').style.display = 'block';
  $('sortRow').style.display = 'flex';
  $('resultsSection').style.display = 'block';
  $('textSearch').style.display = (m === 'text') ? 'block' : 'none';

  const g = $('drawGuide');
  if(g){
    g.textContent = (m === 'map' || m === 'near') ? 'Select a drawing tool, then mark an area to load golf data' : 'Type a location to load golf data';
  }

  if(m === 'map') setLivePill(idlePillText());
  else if(m === 'near') setLivePill('Finding courses near you');

    const g0 = $('drawGuide');
    if(g0){ g0.style.display = ''; g0.textContent = 'Finding courses near you'; }
  else setLivePill('Type a location to load golf data');

  initUserBias();

  initMap();
  setTimeout(() => map && map.invalidateSize(), 60);
  if(m === 'near') setTimeout(() => { try{ doNearMe(); } catch(e){} }, 120);
  refresh();
};

  const fixTop = () => {
    const h = document.querySelector('header');
    const fw = $('filtersWrap');
    if(!h || !fw) return;
    const topPx = (Math.round(h.getBoundingClientRect().height) + 10);
    document.documentElement.style.setProperty('--stickyTop', topPx + 'px');
  };

  // Menu
  const menuBtn = $('menuBtn');
  const menuPanel = $('menuPanel');
  if(menuBtn && menuPanel){
    const closeMenu = () => { menuPanel.style.display = 'none'; menuBtn.setAttribute('aria-expanded','false'); };
    const openMenu = () => { menuPanel.style.display = 'block'; menuBtn.setAttribute('aria-expanded','true'); };
    closeMenu();
    menuBtn.addEventListener('click', (e) => { e.stopPropagation(); if(menuPanel.style.display === 'block') closeMenu(); else openMenu(); });
    document.addEventListener('click', (e) => { if(!menuPanel.contains(e.target) && e.target !== menuBtn) closeMenu(); });
    document.addEventListener('keydown', (e) => { if(e.key === 'Escape') closeMenu(); });
  }

  // Events

  
  // ------------------------------
  // Filters: apply only on button (FINAL, ROBUST)
  // ------------------------------
  const ensureFiltersConfirm = () => {
    let el = document.getElementById('filtersConfirm');
    if (el) return el;

    // Create modal dynamically so it always exists before wiring
    el = document.createElement('div');
    el.className = 'mini-modal';
    el.id = 'filtersConfirm';
    el.setAttribute('aria-hidden', 'true');
    el.innerHTML = `
      <div class="mini-backdrop" data-filters-cancel></div>
      <div class="mini-panel" role="dialog" aria-modal="true" aria-label="Clear filters confirmation">
        <div class="mini-text">Are you sure you want to clear all filters</div>
        <div class="mini-actions">
          <button class="btn" id="filtersConfirmNo" type="button">No</button>
          <button class="btn btn-primary" id="filtersConfirmYes" type="button">Yes</button>
        </div>
      </div>`;
    document.body.appendChild(el);
    return el;
  };

  const ensureModeValid = () => {
    if (mode !== 'map' && mode !== 'text' && mode !== 'near') setMode('map');
  };

  const runApplyFilters = () => {
    ensureModeValid();
    // Use the existing pipeline (reads ticked boxes, updates UI, refreshes list + map)
    applyFilters();
    // Belt-and-braces refresh in case applyFilters pipeline was modified elsewhere
    refresh();
  };

  const runClearFiltersNow = () => {
    ensureModeValid();
    clearFilters();
    refresh();
  };

  const filtersConfirmEl = ensureFiltersConfirm();

  const openFiltersConfirm = () => {
    if(!filtersConfirmEl) return;
    filtersConfirmEl.classList.add('show');
    filtersConfirmEl.setAttribute('aria-hidden','false');
  };
  const closeFiltersConfirm = () => {
    if(!filtersConfirmEl) return;
    filtersConfirmEl.classList.remove('show');
    filtersConfirmEl.setAttribute('aria-hidden','true');
  };

  // Apply (header + footer)
  $('applyFiltersBtn') && $('applyFiltersBtn').addEventListener('click', runApplyFilters);
  $('applyFiltersBtnTop') && $('applyFiltersBtnTop').addEventListener('click', runApplyFilters);

  // Clear (requires confirmation)
  $('clearFiltersBtn') && $('clearFiltersBtn').addEventListener('click', openFiltersConfirm);
  $('clearFiltersBtnBottom') && $('clearFiltersBtnBottom').addEventListener('click', openFiltersConfirm);

  // Modal actions
  document.addEventListener('click', (e) => {
    if(!filtersConfirmEl) return;
    if(e.target && (e.target.hasAttribute('data-filters-cancel') || e.target.id === 'filtersConfirmNo')){
      closeFiltersConfirm();
    }
    if(e.target && e.target.id === 'filtersConfirmYes'){
      closeFiltersConfirm();
      runClearFiltersNow();
    }
  });
document.querySelectorAll('[data-mode]').forEach(b => b.addEventListener('click', () => setMode(b.getAttribute('data-mode'))));
  $('sortSelect').addEventListener('change', (e) => { sort = e.target.value; refresh(); });
  $('clearAreaBtn').addEventListener('click', clearArea);
  const rv = $('resetViewBtn');
  if(rv) rv.addEventListener('click', resetView);

  // Text Search controls
  const goBtn = $('textGo');
  const qEl = $('textQuery');
  if(goBtn) goBtn.addEventListener('click', doTextSearch);
  if(qEl) qEl.addEventListener('keydown', (e) => { if(e.key === 'Enter') doTextSearch(); });
  const rEl = $('radiusSelect');
  if(rEl) rEl.addEventListener('change', () => { radiusOverride = true; });

  // Autocomplete
  if(qEl){
    qEl.addEventListener('input', () => {
      selectedTextHit = null;
      if(acTimer) clearTimeout(acTimer);
      acTimer = setTimeout(() => fetchTextSuggestions(qEl.value), 220);
    });
    qEl.addEventListener('focus', () => {
      if(lastTextHits.length) renderAc(lastTextHits);
      else fetchTextSuggestions(qEl.value);
    });
    qEl.addEventListener('blur', () => {
      // Give clicks a moment to register
      setTimeout(closeAc, 120);
    });
  }

  document.addEventListener('keydown', (e) => { if(e.key === 'Escape') closeAc(); });
document.querySelectorAll('#filtersPanel input[type="checkbox"]').forEach(cb => cb.addEventListener('change', () => { /* pending only */ }));
  $('closeSidePanel')?.addEventListener('click', closeSidePanel);
  // Close quick view if user starts drawing a new area
  document.addEventListener('keydown', (e) => { if(e.key === 'Escape') closeSidePanel(); });

  window.addEventListener('load', fixTop);
  window.addEventListener('resize', fixTop);
  setTimeout(fixTop, 50);

  // Full Details: open a dedicated page in a new tab, no interaction with this page after opening.
  document.addEventListener('click', (e) => {
    const el = e.target && e.target.closest ? e.target.closest('[data-details]') : null;
    if(!el) return;
    const id = el.getAttribute('data-details');
    if(!id) return;
    // Allow default anchor behaviour when present, but ensure it always opens in a new tab.
    if(el.tagName && el.tagName.toLowerCase() === 'a') {
      // Ensure correct href in case markup was modified elsewhere
      el.setAttribute('href', './gdb_course_detail.html?id=' + encodeURIComponent(id));
      el.setAttribute('target', '_blank');
      el.setAttribute('rel', 'noopener');
      return;
    }
    e.preventDefault();
    window.open('./gdb_course_detail.html?id=' + encodeURIComponent(id), '_blank', 'noopener');
  });


  // Full details open in new tab (stable)
  function openCourseDetailsInNewTab(id){
    if(id === undefined || id === null) return;
    const url = `./gdb_course_detail.html?id=${encodeURIComponent(String(id))}`;
    try{
      window.open(url, '_blank', 'noopener');
    }catch(e){
      const a = document.createElement('a');
      a.href = url;
      a.target = '_blank';
      a.rel = 'noopener';
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
  }
  window.openCourseDetailsInNewTab = openCourseDetailsInNewTab;

})();
</script>
<footer class="site-footer">© 2025 Golf Done Better. Bookings happen on partner sites.</footer>
<!-- Toast -->
<div id="gdbToast" role="status" aria-live="polite"></div>

<!-- Compare widget -->
<div id="compareWidget" aria-label="Compare widget" style="display:none">
  <div class="compare-widget-inner">
    <div class="compare-widget-title">Compare</div>
    <div class="compare-widget-sub"><span id="compareCount">0</span> selected</div>
  </div>
  <button class="compare-open" id="compareOpenBtn" type="button" onclick="event.preventDefault(); event.stopPropagation(); if(window.openCompareModal){ try{ window.try{ openCompareModal(); }catch(e){ console.error(e); const mm=document.getElementById('compareModal'); if(mm){ mm.classList.add('show'); mm.setAttribute('aria-hidden','false'); } } }catch(e){ console.error(e); const mm=document.getElementById('compareModal'); if(mm){mm.classList.add('show');mm.setAttribute('aria-hidden','false');}} }">View</button>
  <button class="compare-open" id="compareClearAllBtn" type="button" style="margin-left:8px;opacity:.9">Clear</button>
</div>

<!-- Compare modal -->
<div class="compare-modal" id="compareModal" aria-hidden="true">
  <div class="compare-backdrop" data-compare-close></div>
  <div class="compare-panel" role="dialog" aria-modal="true" aria-label="Compare courses">
    <div class="compare-head">
      <div>
        <div class="compare-title">Compare courses</div>
        <div class="compare-sub">Up to 6. Remove to adjust.</div>
      </div>
      <button class="compare-x" type="button" data-compare-close aria-label="Close">✕</button>
    </div>
    <div class="compare-grid" id="compareGrid"></div>
  </div>
</div>

<!-- Compare clear confirmation -->
<div class="mini-modal" id="compareConfirm" aria-hidden="true">
  <div class="mini-backdrop" data-ccancel></div>
  <div class="mini-panel" role="dialog" aria-modal="true" aria-label="Clear compare selection">
    <div class="mini-text">Clear all courses selected for comparison</div>
    <div class="mini-actions">
      <button class="btn" id="compareConfirmNo" type="button">No</button>
      <button class="btn btn-primary" id="compareConfirmYes" type="button">Yes</button>
    </div>
  </div>
</div>


<!-- Clear filters confirmation -->
<div class="mini-modal" id="filtersConfirm" aria-hidden="true">
  <div class="mini-backdrop" data-filters-cancel></div>
  <div class="mini-panel" role="dialog" aria-modal="true" aria-label="Clear filters confirmation">
    <div class="mini-text">Are you sure you want to clear all filters</div>
    <div class="mini-actions">
      <button class="btn" id="filtersConfirmNo" type="button">No</button>
      <button class="btn btn-primary" id="filtersConfirmYes" type="button">Yes</button>
    </div>
  </div>
</div>

</body>
</html>

<script>
/* ===============================
   GDB COURSE LOGIC v1
   Classification + Normalisation
   Non-breaking helpers
   =============================== */

(function(){
  function has(val){ return val !== undefined && val !== null && val !== ""; }

  function normStr(s){ return (s||"").toString().toLowerCase(); }

  function getWebsite(tags){
    return tags.website || tags["contact:website"] || null;
  }

  function classifyCourse(tags, name){
    const n = normStr(name);
    const hasRange = tags.golf === "driving_range" || n.includes("driving range");
    const hasCourse =
      tags.leisure === "golf_course" ||
      tags.golf === "course" ||
      (parseInt(tags["golf:holes"]||0,10) >= 9);

    if (hasCourse && hasRange) return "mixed_course";
    if (hasCourse) return "full_course";
    if (hasRange) return "range_only";
    return "unknown";
  }

  function scoreCourse(tags, geometryType, category, website, wiki){
    let score = 0;
    if (geometryType === "polygon") score += 30;
    const holes = parseInt(tags["golf:holes"]||0,10);
    if (holes >= 18) score += 20;
    if (website) score += 10;
    if (wiki) score += 10;
    if (geometryType === "node") score -= 10;
    if (category === "range_only") score -= 25;
    return score;
  }

  // Main normaliser
  window.GDB_normaliseCourse = function(feature){
    const tags = feature.tags || {};
    const name = tags.name || "Unnamed golf course";
    const category = classifyCourse(tags, name);
    const website = getWebsite(tags);
    const wiki = tags.wikipedia || tags.wikidata || null;

    const geometryType =
      feature.type === "way" || feature.type === "relation" ? "polygon" : "node";

    const confidenceScore = scoreCourse(tags, geometryType, category, website, wiki);

    return {
      id: feature.id || (name + "_" + Math.random().toString(36).slice(2)),
      name: name,
      lat: feature.lat,
      lng: feature.lon,
      town: tags["addr:city"] || tags["addr:town"] || null,
      region: tags["addr:state"] || tags["addr:region"] || null,
      country: tags["addr:country"] || null,
      courseCategory: category,
      confidenceScore: confidenceScore,
      websiteUrl: website,
      holes: has(tags["golf:holes"]) ? parseInt(tags["golf:holes"],10) : null,
      par: has(tags["golf:par"]) ? parseInt(tags["golf:par"],10) : null,
      lengthYards: has(tags["golf:length"]) ? parseInt(tags["golf:length"],10) : null,
      access: tags.access || "unknown",
      rawTags: tags
    };
  };

  console.log("GDB Course Logic v1 loaded");
})();
</script>

<script>
/* ===============================
   GDB ACCOMMODATION LOGIC v1
   Classification + Normalisation
   Non-breaking helpers
   =============================== */

(function(){
  function has(val){ return val !== undefined && val !== null && val !== ""; }
  function normStr(s){ return (s||"").toString().toLowerCase(); }

  const INCLUDE_TYPES = [
    "hotel","resort","guest_house","aparthotel",
    "lodge","inn","serviced_apartment"
  ];

  const BORDERLINE_TYPES = [
    "bed_and_breakfast","holiday_home","chalet","villa"
  ];

  const EXCLUDE_TYPES = [
    "camp_site","campsite","caravan_site","hostel",
    "wilderness_hut","alpine_hut","tent","motorhome_stopover","farm"
  ];

  function classifyAccommodation(tags, name){
    const n = normStr(name);
    const type = tags.tourism || tags.building || "";

    if (EXCLUDE_TYPES.includes(type) || n.includes("camp") || n.includes("caravan")) {
      return "excluded";
    }
    if (INCLUDE_TYPES.includes(type)) return "stay";
    if (BORDERLINE_TYPES.includes(type)) return "borderline";
    return "unknown";
  }

  function scoreAccommodation(tags, geometryType, category, website, wiki){
    let score = 0;
    if (geometryType === "polygon") score += 25;
    if (website) score += 10;
    if (wiki) score += 10;
    if (category === "borderline") score -= 10;
    if (category === "excluded") score -= 50;
    if (geometryType === "node") score -= 5;
    return score;
  }

  window.GDB_normaliseAccommodation = function(feature){
    const tags = feature.tags || {};
    const name = tags.name || "Unnamed accommodation";
    const category = classifyAccommodation(tags, name);
    const website = tags.website || tags["contact:website"] || null;
    const wiki = tags.wikipedia || tags.wikidata || null;

    const geometryType =
      feature.type === "way" || feature.type === "relation" ? "polygon" : "node";

    const confidenceScore = scoreAccommodation(tags, geometryType, category, website, wiki);

    return {
      id: feature.id || (name + "_" + Math.random().toString(36).slice(2)),
      name: name,
      lat: feature.lat,
      lng: feature.lon,
      town: tags["addr:city"] || tags["addr:town"] || null,
      region: tags["addr:state"] || tags["addr:region"] || null,
      country: tags["addr:country"] || null,
      accommodationCategory: category, // stay | borderline | excluded | unknown
      confidenceScore: confidenceScore,
      websiteUrl: website,
      stars: tags.stars || null,
      roomsHint: tags.rooms || null,
      rawTags: tags
    };
  };

  console.log("GDB Accommodation Logic v1 loaded");
})();
</script>

<script>
/* ===============================
   GDB DOM PAGINATION v1
   Non-invasive pagination for long result lists
   Works by hiding/showing existing cards in #resultsList
   =============================== */
(function(){
  const KEY_PER = "gdb_results_per_page";
  const KEY_PAGE = "gdb_results_page";
  const ALLOWED = [10,25,50];

  function getPerPage(){
    const raw = Number(localStorage.getItem(KEY_PER) || "10");
    return ALLOWED.includes(raw) ? raw : 10;
  }
  function setPerPage(v){
    const n = Number(v);
    localStorage.setItem(KEY_PER, String(ALLOWED.includes(n) ? n : 10));
  }
  function getPage(){ return Math.max(1, Math.floor(Number(localStorage.getItem(KEY_PAGE) || "1") || 1)); }
  function setPage(p){ localStorage.setItem(KEY_PAGE, String(Math.max(1, Math.floor(Number(p)||1)))); }

  function buildPager(suffix, state){
    const wrap = document.createElement("div");
    wrap.dataset.gdbPager = suffix;
    wrap.style.border = "1px solid rgba(255,255,255,.14)";
    wrap.style.background = "rgba(255,255,255,.04)";
    wrap.style.borderRadius = "16px";
    wrap.style.padding = "12px";
    wrap.style.marginTop = "10px";

    wrap.innerHTML = `
      <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:space-between;align-items:center;">
        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
          <button type="button" class="btn sm" data-gdb-prev>Prev</button>
          <div class="pill" data-gdb-pill>Page ${state.page} of ${state.totalPages}</div>
          <button type="button" class="btn sm" data-gdb-next>Next</button>
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
          <label class="small" style="font-weight:900;">Results</label>
          <select class="select" data-gdb-per style="background:#ffffff;color:#000000;">
            ${ALLOWED.map(n => `<option value="${n}" ${n===state.perPage?'selected':''}>${n} per page</option>`).join("")}
          </select>
          <label class="small" style="font-weight:900;">Go to</label>
          <input data-gdb-go-input inputmode="numeric" placeholder="${state.page}"
            style="height:40px;min-width:120px;max-width:140px;border-radius:14px;border:1px solid rgba(255,255,255,.18);background:#000000;color:#ffffff;padding:0 12px;outline:none;" />
          <button type="button" class="btn sm" data-gdb-go>Go</button>
        </div>
      </div>
    `;

    const prev = wrap.querySelector("[data-gdb-prev]");
    const next = wrap.querySelector("[data-gdb-next]");
    if(prev) prev.disabled = state.page <= 1;
    if(next) next.disabled = state.page >= state.totalPages;

    return wrap;
  }

  function applyPagination(){
    const container = document.getElementById("resultsList");
    if(!container) return;

    // Cards only, ignore our pagers
    const cards = Array.from(container.children).filter(el => {
      if(el && el.dataset && el.dataset.gdbPager) return false;
      return el.classList.contains("course-card") || el.classList.contains("stay-card") || el.classList.contains("result-card");
    });

    // Remove existing pagers
    Array.from(container.children).forEach(el => { if(el && el.dataset && el.dataset.gdbPager) el.remove(); });

    if(cards.length === 0) return;

    const perPage = getPerPage();
    let page = getPage();
    const totalPages = Math.max(1, Math.ceil(cards.length / perPage));
    if(page > totalPages) page = totalPages;
    setPage(page);

    const start = (page - 1) * perPage;
    const end = start + perPage;

    cards.forEach((el, idx) => {
      el.style.display = (idx >= start && idx < end) ? "" : "none";
    });

    const topPager = buildPager("Top", { perPage, page, totalPages });
    const botPager = buildPager("Bot", { perPage, page, totalPages });

    // Insert top before first card
    container.insertBefore(topPager, container.firstChild);

    // Insert bottom after last visible card (or end)
    container.appendChild(botPager);

    function wire(pagerEl){
      const perSel = pagerEl.querySelector("[data-gdb-per]");
      const prev = pagerEl.querySelector("[data-gdb-prev]");
      const next = pagerEl.querySelector("[data-gdb-next]");
      const goBtn = pagerEl.querySelector("[data-gdb-go]");
      const goInput = pagerEl.querySelector("[data-gdb-go-input]");

      if(perSel) perSel.onchange = () => { setPerPage(perSel.value); setPage(1); applyPagination(); };
      if(prev) prev.onclick = () => { setPage(page - 1); applyPagination(); };
      if(next) next.onclick = () => { setPage(page + 1); applyPagination(); };
      if(goBtn) goBtn.onclick = () => {
        const v = Number((goInput && goInput.value) ? goInput.value.trim() : "");
        if(!Number.isFinite(v)) return;
        setPage(Math.min(totalPages, Math.max(1, Math.floor(v))));
        applyPagination();
      };
      if(goInput) goInput.onkeydown = (ev) => { if(ev.key === "Enter"){ ev.preventDefault(); if(goBtn) goBtn.click(); } };
    }

    wire(topPager);
    wire(botPager);
  }

  // Observe changes so pagination always reapplies after a new search / filter
  function boot(){
    const container = document.getElementById("resultsList");
    if(!container) return;

    // First pass
    applyPagination();

    const obs = new MutationObserver((mutations) => {
      // If real cards added/removed, reapply
      let needs = false;
      for(const m of mutations){
        if(m.type === "childList"){
          const added = Array.from(m.addedNodes || []).some(n => n && n.classList && (n.classList.contains("course-card") || n.classList.contains("stay-card") || n.classList.contains("result-card")));
          const removed = Array.from(m.removedNodes || []).some(n => n && n.classList && (n.classList.contains("course-card") || n.classList.contains("stay-card") || n.classList.contains("result-card")));
          if(added || removed){ needs = true; break; }
        }
      }
      if(needs) applyPagination();
    });

    obs.observe(container, { childList:true });
  }

  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", boot);
  } else {
    boot();
  }

  // Compare modal wiring

  // Ensure compare globals are available in this scope
  const compareSet = window.compareSet || new Set();
  const compareMax = window.compareMax || 6;
  const saveCompare = window.saveCompare || (()=>{});
  const updateCompareUi = window.updateCompareUi || (()=>{});
  const toast = window.toast || ((m)=>{ try{ console.warn(m);}catch(e){} });
  const openCompareModal = () => {
    try{
      if (compareSet.size < 2) {
        toast('Select at least 2 courses to compare');
        return;
      }

      const modal = document.getElementById('compareModal');
      const grid = document.getElementById('compareGrid');
      if (!modal || !grid) return;

      const escape = (typeof escapeHtml === 'function') ? escapeHtml : (s) => String(s ?? '').replace(/[&<>"']/g, (c)=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));
      const tc = (typeof titleCase === 'function') ? titleCase : (s) => String(s ?? '').replace(/_/g,' ').replace(/\b\w/g, ch => ch.toUpperCase());
      const lbls = (typeof labels === 'function') ? labels : (arr) => (Array.isArray(arr)?arr.map(tc):[]);

      // Selected ids (max 6)
      const ids = [...compareSet].slice(0, compareMax).map(String);

      // Build or reuse course index
      if(!window.__gdbCourseIndex){
        const idx = new Map();
        const addAll = (arr) => Array.isArray(arr) && arr.forEach(c => { if(c && c.id != null) idx.set(String(c.id), c); });
        addAll(Array.isArray(window.currentResults) ? window.currentResults : (Array.isArray(currentResults) ? currentResults : []));
        addAll(typeof GDB_COURSES !== 'undefined' ? GDB_COURSES : []);
        window.__gdbCourseIndex = idx;
      }
      const index = window.__gdbCourseIndex;

      const items = ids.map(id => index.get(id)).filter(Boolean);

      // If still empty, show a clear message (so we know mapping is the issue)
      if(items.length === 0){
        grid.innerHTML = `<div style="padding:16px;opacity:.85">No matching course data found for selected comparisons. (IDs: ${escape(ids.join(', '))})</div>`;
        modal.classList.add('show');
        modal.setAttribute('aria-hidden','false');
        return;
      }

      const pick = (...vals) => vals.find(v => v != null && String(v).trim() !== '' && String(v).trim().toLowerCase() !== 'unknown') || '';
      const niceAccess = (v) => v === 'public' ? 'Public' : v === 'visitors' ? 'Visitors welcome' : v === 'members_only' ? 'Members only' : 'Unknown';
      const joinLabels = (arr, mapFn) => Array.isArray(arr) && arr.length ? arr.map(mapFn || (x=>x)).filter(Boolean).join(', ') : 'Unknown';
      const extrasLabel = (x) => x === 'alcohol_allowed' ? 'Alcohol allowed on course' : x === 'smoking_allowed' ? 'Smoking allowed on course' : tc(x);

      grid.innerHTML = items.map(c => {
        const id = String(c.id);
        const img = (typeof imageCache !== 'undefined' && imageCache.get && imageCache.get(id)) ? imageCache.get(id) : (window.PLACEHOLDER_IMG || (typeof PLACEHOLDER_IMG !== 'undefined' ? PLACEHOLDER_IMG : ''));
        const name = c.name || 'Golf course';
        const city = pick(c.city, c.place, c.town, c.area);
        const postcode = pick(c.postcode, c.address && c.address.postcode, c.source && c.source.postcode);
        const address = (typeof c.address === 'string') ? c.address :
          (c.address && typeof c.address === 'object') ? [c.address.line1,c.address.line2,c.address.town,c.address.city,c.address.county].filter(Boolean).join(', ') :
          pick(c.full_address, c.street_address, c.source && (c.source.address || c.source.location));
        const phone = pick(c.phone, c.telephone, c.source && (c.source.phone || c.source.telephone));
        const website = pick(c.website, c.url, c.link, c.source && (c.source.website || c.source.url));
        const affiliate = pick(c.affiliate_link, c.affiliate, c.source && (c.source.affiliate || c.source.affiliate_link));
        const desc = pick(c.short_description, c.description, c.info, c.source && (c.source.short_description || c.source.description));

        const holes = pick(c.holes) || 'Unknown';
        const par = pick(c.par) || 'Unknown';
        const access = niceAccess(String(c.access || 'unknown'));
        const priceBand = pick(c.price_band) ? tc(c.price_band) : 'Unknown';

        const difficulty = (c.difficulty && c.difficulty.length) ? lbls(c.difficulty).join(', ') : 'Unknown';
        const dress = (c.dress_code && c.dress_code.length) ? c.dress_code.map(x => x === 'smart_casual' ? 'Smart casual' : tc(x)).join(', ') : 'Unknown';
        const vibe = (c.vibe && c.vibe.length) ? lbls(c.vibe).join(', ') : 'Unknown';
        const courseType = (c.course_type && c.course_type.length) ? lbls(c.course_type).join(', ') : 'Unknown';
        const facilities = (c.facilities && c.facilities.length) ? c.facilities.map(x => x === 'practice_area' ? 'Practice areas' : tc(x)).join(', ') : 'Unknown';
        const extras = (c.extras && c.extras.length) ? c.extras.map(extrasLabel).join(', ') : 'Unknown';

        const mapsHref = (c.lat && c.lng) ? `https://www.google.com/maps?q=${encodeURIComponent(String(c.lat)+','+String(c.lng))}` : '';

        return `
          <div class="compare-card">
            <button class="compare-remove" type="button" data-compare-remove="${escape(id)}" aria-label="Remove">✕</button>
            ${img ? `<div class="compare-imgwrap"><img src="${escape(img)}" alt="" loading="lazy"></div>` : ''}
            <div class="compare-body">
              <div class="course-name">${escape(name)}</div>
              <div class="course-location">${escape([city, postcode].filter(Boolean).join(' · ') || '—')}</div>
              ${address ? `<div class="course-location dim">${escape(address)}</div>` : ''}
              ${phone ? `<div class="course-location dim">${escape(phone)}</div>` : ''}

              <div class="compare-meta">
                <div class="meta-row"><span>Holes</span><b>${escape(holes)}</b></div>
                <div class="meta-row"><span>Par</span><b>${escape(par)}</b></div>
                <div class="meta-row"><span>Access</span><b>${escape(access)}</b></div>
                <div class="meta-row"><span>Price</span><b>${escape(priceBand)}</b></div>
                <div class="meta-row"><span>Difficulty</span><b>${escape(difficulty)}</b></div>
                <div class="meta-row"><span>Dress</span><b>${escape(dress)}</b></div>
                <div class="meta-row"><span>Vibe</span><b>${escape(vibe)}</b></div>
                <div class="meta-row"><span>Type</span><b>${escape(courseType)}</b></div>
                <div class="meta-row meta-wide"><span>Facilities</span><b>${escape(facilities)}</b></div>
                <div class="meta-row meta-wide"><span>Extras</span><b>${escape(extras)}</b></div>
              </div>

              ${desc ? `<div class="compare-desc">${escape(desc)}</div>` : ''}

              <div class="compare-links">
                <a class="link" href="./gdb_course_detail.html?id=${encodeURIComponent(id)}" target="_blank" rel="noopener">Full details</a>
                ${mapsHref ? `<a class="link" href="${escape(mapsHref)}" target="_blank" rel="noopener">Maps</a>` : ''}
                ${website ? `<a class="link" href="${escape(website)}" target="_blank" rel="noopener">Website</a>` : ''}
                ${affiliate ? `<a class="link" href="${escape(affiliate)}" target="_blank" rel="noopener">Affiliate</a>` : ''}
              </div>
            </div>
          </div>
        `;
      }).join('');

      modal.classList.add('show');
      modal.setAttribute('aria-hidden','false');
      modal.dataset.count = String(items.length);

      grid.querySelectorAll('[data-compare-remove]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const id = e.currentTarget.getAttribute('data-compare-remove');
          if (id) compareSet.delete(String(id));
          saveCompare();
          updateCompareUi();

          if (compareSet.size < 2) {
            toast('Comparison needs at least 2 courses');
            closeCompareModal();
            return;
          }
          // Refresh modal view
          openCompareModal();
        });
      });
    }catch(err){
      console.error(err);
      toast('Compare view failed to load');
    }
  };
  // Expose for hard-wired button click
  window.openCompareModal = openCompareModal;
const closeCompareModal = () => {
    const modal = document.getElementById('compareModal');
    if(!modal) return;
    modal.classList.remove('show');
    modal.setAttribute('aria-hidden','true');
  };


  // Compare clear confirmation modal
  const openCompareConfirm = () => {
    const m = document.getElementById('compareConfirm');
    if(!m) return;
    m.classList.add('show');
    m.setAttribute('aria-hidden','false');
    // focus No for safety
    const noBtn = document.getElementById('compareConfirmNo');
    if(noBtn) setTimeout(()=>noBtn.focus(), 0);
  };

  const closeCompareConfirm = () => {
    const m = document.getElementById('compareConfirm');
    if(!m) return;
    m.classList.remove('show');
    m.setAttribute('aria-hidden','true');
  };


  // Robust bindings for compare widget buttons (widget markup sits after main script in the DOM)
  const bindCompareControls = () => {
    const openBtn = document.getElementById('compareOpenBtn');
    const clearBtn = document.getElementById('compareClearAllBtn');

    if(openBtn && !openBtn.dataset.gdbBound){
      openBtn.dataset.gdbBound = '1';
      openBtn.addEventListener('click', (ev) => {
        ev.preventDefault();
        try{ openCompareModal(); }catch(e){ console.error(e); const mm=document.getElementById('compareModal'); if(mm){ mm.classList.add('show'); mm.setAttribute('aria-hidden','false'); } }
      });
    }

    if(clearBtn && !clearBtn.dataset.gdbBound){
      clearBtn.dataset.gdbBound = '1';
      clearBtn.addEventListener('click', (ev) => {
        ev.preventDefault();
        if(compareSet.size === 0) return;
        openCompareConfirm();
      });
    }


    // Confirm clear (bind once)
    const yesBtn = document.getElementById('compareConfirmYes');
    const noBtn = document.getElementById('compareConfirmNo');
    const backdrop = document.querySelector('#compareConfirm [data-ccancel]');

    if(yesBtn && !yesBtn.dataset.gdbBound){
      yesBtn.dataset.gdbBound = '1';
      yesBtn.addEventListener('click', (ev) => {
        ev.preventDefault();
        compareSet.clear();
        saveCompare();
        updateCompareUi();
        closeCompareModal();
        closeCompareConfirm();
      });
    }
    const closeConfirm = (ev) => { if(ev) ev.preventDefault(); closeCompareConfirm(); };
    if(noBtn && !noBtn.dataset.gdbBound){
      noBtn.dataset.gdbBound = '1';
      noBtn.addEventListener('click', closeConfirm);
    }
    if(backdrop && !backdrop.dataset.gdbBound){
      backdrop.dataset.gdbBound = '1';
      backdrop.addEventListener('click', closeConfirm);
    }

    document.querySelectorAll('[data-compare-close]').forEach(el => {
      if(el.dataset.gdbBound) return;
      el.dataset.gdbBound = '1';
      el.addEventListener('click', (ev) => {
        ev.preventDefault();
        closeCompareModal();
      });
    });
  };

  const ensureCompareBindings = () => {
    bindCompareControls();
    // a couple of retries in case markup arrives later
    setTimeout(bindCompareControls, 0);
    setTimeout(bindCompareControls, 200);
    setTimeout(bindCompareControls, 600);
  };

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureCompareBindings);
  } else {
    ensureCompareBindings();
  }

  // One-time bindings (delegated: widget markup is after this script)
  document.addEventListener('click', (ev) => {
    const t = ev.target;
    if(!t || !t.closest) return;

    if(t.closest('#compareOpenBtn')){
      ev.preventDefault();
      try{ openCompareModal(); }catch(e){ console.error(e); const mm=document.getElementById('compareModal'); if(mm){ mm.classList.add('show'); mm.setAttribute('aria-hidden','false'); } }
      return;
    }

    if(t.closest('#compareClearAllBtn')){
      ev.preventDefault();
      if(compareSet.size === 0) return;
      openCompareConfirm();
      return;
    }


    if(t.closest('[data-compare-close]')){
      ev.preventDefault();
      closeCompareModal();
      return;
    }
  });

  document.addEventListener('keydown', (e) => { if(e.key === 'Escape') closeCompareModal(); });

  // Compare widget: click to open, drag to reposition
  const __cmpWidget = document.getElementById('compareWidget');
  if(__cmpWidget){
    let dragging = false;
    let moved = false;
    let startX = 0, startY = 0, startLeft = 0, startTop = 0;

    const getPoint = (ev) => {
      const t = ev.touches && ev.touches[0];
      return { x: t ? t.clientX : ev.clientX, y: t ? t.clientY : ev.clientY };
    };

    const onDown = (ev) => {
      if(ev.target && ev.target.closest && (ev.target.closest('#compareOpenBtn') || ev.target.closest('#compareClearAllBtn'))) return;
      dragging = true;
      moved = false;
      __cmpWidget.style.transform = 'none';
      __cmpWidget.style.cursor = 'grabbing';
      const rect = __cmpWidget.getBoundingClientRect();
      startLeft = rect.left;
      startTop = rect.top;
      const p = getPoint(ev);
      startX = p.x;
      startY = p.y;
      // Switch to top/left positioning so it can move freely
      __cmpWidget.style.right = 'auto';
      __cmpWidget.style.bottom = 'auto';
      __cmpWidget.style.left = startLeft + 'px';
      __cmpWidget.style.top = startTop + 'px';
      __cmpWidget.style.transform = 'none';
      ev.preventDefault();
    };

    const onMove = (ev) => {
      if(!dragging) return;
      const p = getPoint(ev);
      const dx = p.x - startX;
      const dy = p.y - startY;
      if(Math.abs(dx) + Math.abs(dy) > 3) moved = true;

      const maxLeft = window.innerWidth - __cmpWidget.offsetWidth - 10;
      const maxTop  = window.innerHeight - __cmpWidget.offsetHeight - 10;
      const nextLeft = Math.min(Math.max(10, startLeft + dx), Math.max(10, maxLeft));
      const nextTop  = Math.min(Math.max(10, startTop + dy), Math.max(10, maxTop));

      __cmpWidget.style.left = nextLeft + 'px';
      __cmpWidget.style.top = nextTop + 'px';
      ev.preventDefault();
    };

    const onUp = () => {
      if(!dragging) return;
      dragging = false;
      __cmpWidget.style.cursor = 'grab';
    };

    __cmpWidget.addEventListener('mousedown', onDown);
    __cmpWidget.addEventListener('touchstart', onDown, {passive:false});
    window.addEventListener('mousemove', onMove, {passive:false});
    window.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('mouseup', onUp);
    window.addEventListener('touchend', onUp);

    // Make the whole widget open the modal (button still works)
    
    // Explicit button wiring (do not rely on widget click/drag logic)
    const __cmpViewBtn = document.getElementById('compareOpenBtn');
    const __cmpClearBtn = document.getElementById('compareClearAllBtn');
    if(__cmpViewBtn){
      __cmpViewBtn.addEventListener('click', (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        try{ openCompareModal(); }catch(e){ console.error(e); const mm=document.getElementById('compareModal'); if(mm){ mm.classList.add('show'); mm.setAttribute('aria-hidden','false'); } }
      });
    }
    if(__cmpClearBtn){
      __cmpClearBtn.addEventListener('click', (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        // show existing black confirm modal
        const cc = document.getElementById('compareConfirm');
        if(cc){
          cc.classList.add('show');
          cc.setAttribute('aria-hidden','false');
        } else {
          compareSet.clear();
          saveCompare();
          updateCompareUi();
        }
      });
    }

__cmpWidget.addEventListener('click', (ev) => {
      if(ev.target && ev.target.closest && (ev.target.closest('#compareOpenBtn') || ev.target.closest('#compareClearAllBtn'))) return;
      if(moved) return;
      try{ openCompareModal(); }catch(e){ console.error(e); const mm=document.getElementById('compareModal'); if(mm){ mm.classList.add('show'); mm.setAttribute('aria-hidden','false'); } }
    });
  }


})();
</script>
